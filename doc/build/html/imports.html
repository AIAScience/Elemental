

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Imported library routines &mdash; Elemental 0.71 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.71',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Elemental 0.71 documentation" href="index.html" />
    <link rel="next" title="Core functionality" href="core.html" />
    <link rel="prev" title="Build system" href="build.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="core.html" title="Core functionality"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="build.html" title="Build system"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Elemental 0.71 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="imported-library-routines">
<h1>Imported library routines<a class="headerlink" href="#imported-library-routines" title="Permalink to this headline">¶</a></h1>
<p>Since one of the goals of Elemental is to provide high-performance
datatype-independent parallel routines, yet Elemental&#8217;s dependencies are
datatype-dependent, it is convenient to first build a thin datatype-independent
abstraction on top of the necessary routines from BLAS, LAPACK, and MPI. The
&#8220;first-class&#8221; datatypes are <tt class="docutils literal"><span class="pre">float</span></tt>, <tt class="docutils literal"><span class="pre">double</span></tt>, <tt class="docutils literal"><span class="pre">std::complex&lt;float&gt;</span></tt>, and
<tt class="docutils literal"><span class="pre">std::complex&lt;double&gt;</span></tt>, but <tt class="docutils literal"><span class="pre">int</span></tt> and <tt class="docutils literal"><span class="pre">byte</span></tt> (<tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt>) are
supported for many cases, and support for higher precision arithmetic is in the
works.</p>
<div class="section" id="blas">
<h2>BLAS<a class="headerlink" href="#blas" title="Permalink to this headline">¶</a></h2>
<p>The Basic Linear Algebra Subprograms (BLAS) are heavily exploited within
Elemental in order to achieve high performance whenever possible. Since the
official BLAS interface uses different routine names for different datatypes,
the following interfaces are built directly on top of the datatype-specific
versions.</p>
<div class="section" id="level-1">
<h3>Level 1<a class="headerlink" href="#level-1" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="blas::Axpy__i.T.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Axpy</tt><big>(</big>int <em>n</em>, T <em>alpha</em>, const T* <em>x</em>, int <em>incx</em>, T* <em>y</em>, int <em>incy</em><big>)</big><a class="headerlink" href="#blas::Axpy__i.T.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs <img class="math" src="_images/math/51606bf346a9b6d973d3ea2c1412d61642ba63e6.png" alt="y := \alpha x + y"/> for vectors <img class="math" src="_images/math/7d3f43d1ae3bbc4948212afe60c50a18c245f651.png" alt="x,y \in T^n"/> and
scalar <img class="math" src="_images/math/82269ec48a95972264c17f9e72022e38d5675939.png" alt="\alpha \in T"/>. <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> must be stored such that
<img class="math" src="_images/math/67bc6daa9d6b964201d6cef60cbeb1ac5fd26ead.png" alt="x_i"/> occurs at <tt class="docutils literal"><span class="pre">x[i*incx]</span></tt> (and likewise for <tt class="docutils literal"><span class="pre">y</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt id="blas::Dot__i.TCP.i.TP.i">
T <tt class="descclassname">blas::</tt><tt class="descname">Dot</tt><big>(</big>int <em>n</em>, const T* <em>x</em>, int <em>incx</em>, T* <em>y</em>, int <em>incy</em><big>)</big><a class="headerlink" href="#blas::Dot__i.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <img class="math" src="_images/math/fc6715896da12cae298023634d788c78ef4c4a22.png" alt="\alpha := x^H y"/>, where <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> are stored in the
same manner as in <tt class="docutils literal"><span class="pre">blas::Axpy</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Dotc__i.TCP.i.TP.i">
T <tt class="descclassname">blas::</tt><tt class="descname">Dotc</tt><big>(</big>int <em>n</em>, const T* <em>x</em>, int <em>incx</em>, T* <em>y</em>, int <em>incy</em><big>)</big><a class="headerlink" href="#blas::Dotc__i.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">blas::Dot</span></tt>, but this name is kept for historical purposes
(the BLAS provide <tt class="docutils literal"><span class="pre">?dotc</span></tt> and <tt class="docutils literal"><span class="pre">?dotu</span></tt> for complex datatypes).</p>
</dd></dl>

<dl class="function">
<dt id="blas::Dotu__i.TCP.i.TP.i">
T <tt class="descclassname">blas::</tt><tt class="descname">Dotu</tt><big>(</big>int <em>n</em>, const T* <em>x</em>, int <em>incx</em>, T* <em>y</em>, int <em>incy</em><big>)</big><a class="headerlink" href="#blas::Dotu__i.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <tt class="docutils literal"><span class="pre">blas::Dot</span></tt>, but this routine instead returns
<img class="math" src="_images/math/51d107f66e817e47ef78d78d2ea115c6092ba140.png" alt="\alpha := x^T y"/> (<tt class="docutils literal"><span class="pre">x</span></tt> is not conjugated).</p>
</dd></dl>

<dl class="function">
<dt id="blas::Nrm2__i.TCP.i">
RealBase&lt;T&gt;::type <tt class="descclassname">blas::</tt><tt class="descname">Nrm2</tt><big>(</big>int <em>n</em>, const T* <em>x</em>, int <em>incx</em><big>)</big><a class="headerlink" href="#blas::Nrm2__i.TCP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Euclidean two-norm of the vector <tt class="docutils literal"><span class="pre">x</span></tt>, where
<img class="math" src="_images/math/9d509c08269ad874d02c9306ce61259a8aecebb2.png" alt="||x||_2 = \sqrt{\sum_{i=0}^{n-1} |x_i|^2}"/>. Note that if <tt class="docutils literal"><span class="pre">T</span></tt>
represents a complex field, then the return type is the underlying real field
(e.g., <tt class="docutils literal"><span class="pre">T=std::complex&lt;double&gt;</span></tt> results in a return type of <tt class="docutils literal"><span class="pre">double</span></tt>),
otherwise <tt class="docutils literal"><span class="pre">T</span></tt> equals the return type.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Scal__i.T.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Scal</tt><big>(</big>int <em>n</em>, T <em>alpha</em>, T* <em>x</em>, int <em>incx</em><big>)</big><a class="headerlink" href="#blas::Scal__i.T.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs <img class="math" src="_images/math/22c66f3f3b4a8865b4c4d6b77f611f2a4efeb81c.png" alt="x := \alpha x"/>, where <img class="math" src="_images/math/c946ad0cc842f6e4ffb8b378bd2861831d6b70a2.png" alt="x \in T^n"/> is stored in the
manner described in <tt class="docutils literal"><span class="pre">blas::Axpy</span></tt>, and <img class="math" src="_images/math/82269ec48a95972264c17f9e72022e38d5675939.png" alt="\alpha \in T"/>.</p>
</dd></dl>

</div>
<div class="section" id="level-2">
<h3>Level 2<a class="headerlink" href="#level-2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="blas::Gemv__c.i.i.T.TCP.i.TCP.i.T.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Gemv</tt><big>(</big>char <em>trans</em>, int <em>m</em>, int <em>n</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, const T* <em>x</em>, int <em>incx</em>, T <em>beta</em>, T* <em>y</em>, int <em>incy</em><big>)</big><a class="headerlink" href="#blas::Gemv__c.i.i.T.TCP.i.TCP.i.T.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates <img class="math" src="_images/math/fa4dd1ded1d16242a5c69461e7678dfb2e5d0afa.png" alt="y := \alpha \mbox{op}(A) x + \beta y"/>, where
<img class="math" src="_images/math/ed733e10da3a507e22eb621ae3ab78c3d0791e61.png" alt="A \in T^{m \times n}"/> and
<img class="math" src="_images/math/94ec2b01152e3d51f3471e69f3052c67e93b003d.png" alt="\mbox{op}(A) \in \left\{A,A^T,A^H\right\}"/> is chosen by choosing
<tt class="docutils literal"><span class="pre">trans</span></tt> from <img class="math" src="_images/math/ecc2c198c6c5db56ec8ae6acf9caa8bc78c7b926.png" alt="\{N,T,C\}"/>, respectively. Note that <tt class="docutils literal"><span class="pre">x</span></tt> is stored
in the manner repeatedly described in the Level 1 routines, e.g.,
<tt class="docutils literal"><span class="pre">blas::Axpy</span></tt>, but <tt class="docutils literal"><span class="pre">A</span></tt> is stored such that <img class="math" src="_images/math/2387492dcc075889d91293d6df8ef260cdbf2b12.png" alt="A(i,j)"/> is located
at <tt class="docutils literal"><span class="pre">A[i+j*lda]</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Ger__i.i.T.TCP.i.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Ger</tt><big>(</big>int <em>m</em>, int <em>n</em>, T <em>alpha</em>, const T* <em>x</em>, int <em>incx</em>, const T* <em>y</em>, int <em>incy</em>, T* <em>A</em>, int <em>lda</em><big>)</big><a class="headerlink" href="#blas::Ger__i.i.T.TCP.i.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates <img class="math" src="_images/math/a715601517104d722795af8c095d7984ef909101.png" alt="A := \alpha x y^H + A"/>, where <img class="math" src="_images/math/ed733e10da3a507e22eb621ae3ab78c3d0791e61.png" alt="A \in T^{m \times n}"/> and
<tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">y</span></tt>, and <tt class="docutils literal"><span class="pre">A</span></tt> are stored in the manner described in <tt class="docutils literal"><span class="pre">blas::Gemv</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Gerc__i.i.T.TCP.i.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Gerc</tt><big>(</big>int <em>m</em>, int <em>n</em>, T <em>alpha</em>, const T* <em>x</em>, int <em>incx</em>, const T* <em>y</em>, int <em>incy</em>, T* <em>A</em>, int <em>lda</em><big>)</big><a class="headerlink" href="#blas::Gerc__i.i.T.TCP.i.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">blas::Ger</span></tt>, but the name is provided for historical
reasons (the BLAS provides <tt class="docutils literal"><span class="pre">?gerc</span></tt> and <tt class="docutils literal"><span class="pre">?geru</span></tt> for complex datatypes).</p>
</dd></dl>

<dl class="function">
<dt id="blas::Geru__i.i.T.TCP.i.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Geru</tt><big>(</big>int <em>m</em>, int <em>n</em>, T <em>alpha</em>, const T* <em>x</em>, int <em>incx</em>, const T* <em>y</em>, int <em>incy</em>, T* <em>A</em>, int <em>lda</em><big>)</big><a class="headerlink" href="#blas::Geru__i.i.T.TCP.i.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">blas::Ger</span></tt>, but instead perform <img class="math" src="_images/math/c0cc4dd2635666312c73134781b03a13833b902d.png" alt="A := \alpha x y^T + A"/>
(<tt class="docutils literal"><span class="pre">y</span></tt> is not conjugated).</p>
</dd></dl>

<dl class="function">
<dt id="blas::Hemv__c.i.T.TCP.i.TCP.i.T.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Hemv</tt><big>(</big>char <em>uplo</em>, int <em>m</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, const T* <em>x</em>, int <em>incx</em>, T <em>beta</em>, T* <em>y</em>, int <em>incy</em><big>)</big><a class="headerlink" href="#blas::Hemv__c.i.T.TCP.i.TCP.i.T.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs <img class="math" src="_images/math/8b1bf0f00fbd87968ea839435c17c78efbc6eded.png" alt="y := \alpha A x + \beta y"/>, where
<img class="math" src="_images/math/ed733e10da3a507e22eb621ae3ab78c3d0791e61.png" alt="A \in T^{m \times n}"/> is assumed to be Hermitian with the data stored
in either the lower or upper triangle of <tt class="docutils literal"><span class="pre">A</span></tt> (depending upon whether
<tt class="docutils literal"><span class="pre">uplo</span></tt> is equal to &#8216;L&#8217; or &#8216;U&#8217;, respectively).</p>
</dd></dl>

<dl class="function">
<dt id="blas::Her__c.i.T.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Her</tt><big>(</big>char <em>uplo</em>, int <em>m</em>, T <em>alpha</em>, const T* <em>x</em>, int <em>incx</em>, T* <em>A</em>, int <em>lda</em><big>)</big><a class="headerlink" href="#blas::Her__c.i.T.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs <img class="math" src="_images/math/b25fc235dcb33b88a863aed9585ac583c27bf04a.png" alt="A := \alpha x x^H + A"/>, where <img class="math" src="_images/math/d6c6da8b953fe102fdb4a43af722f2d6c067d322.png" alt="A \in T^{m \times m}"/>
is assumed to be Hermitian, with the data stored in the triangle specified
by <tt class="docutils literal"><span class="pre">uplo</span></tt> (depending upon whether <tt class="docutils literal"><span class="pre">uplo</span></tt> is equal to &#8216;L&#8217; or &#8216;U&#8217;,
respectively).</p>
</dd></dl>

<dl class="function">
<dt id="blas::Her2__c.i.T.TCP.i.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Her2</tt><big>(</big>char <em>uplo</em>, int <em>m</em>, T <em>alpha</em>, const T* <em>x</em>, int <em>incx</em>, const T* <em>y</em>, int <em>incy</em>, T* <em>A</em>, int <em>lda</em><big>)</big><a class="headerlink" href="#blas::Her2__c.i.T.TCP.i.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs <img class="math" src="_images/math/2ba80f9399575769c5dcd374933b8e3acdad7e06.png" alt="A := \alpha ( x y^H + y x^H ) + A"/>, where
<img class="math" src="_images/math/d6c6da8b953fe102fdb4a43af722f2d6c067d322.png" alt="A \in T^{m \times m}"/> is assumed to be Hermitian, with the data
stored in the triangle specified by <tt class="docutils literal"><span class="pre">uplo</span></tt> (depending upon whether <tt class="docutils literal"><span class="pre">uplo</span></tt>
is equal to &#8216;L&#8217; or &#8216;U&#8217;, respectively).</p>
</dd></dl>

<dl class="function">
<dt id="blas::Symv__c.i.T.TCP.i.TCP.i.T.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Symv</tt><big>(</big>char <em>uplo</em>, int <em>m</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, const T* <em>x</em>, int <em>incx</em>, T <em>beta</em>, T* <em>y</em>, int <em>incy</em><big>)</big><a class="headerlink" href="#blas::Symv__c.i.T.TCP.i.TCP.i.T.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as <tt class="docutils literal"><span class="pre">blas::Hemv</span></tt>, but <img class="math" src="_images/math/d6c6da8b953fe102fdb4a43af722f2d6c067d322.png" alt="A \in T^{m \times m}"/> is instead
assumed to be <em>symmetric</em>, and the update is
<img class="math" src="_images/math/8b1bf0f00fbd87968ea839435c17c78efbc6eded.png" alt="y := \alpha A x + \beta y"/>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Syr__c.i.T.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Syr</tt><big>(</big>char <em>uplo</em>, int <em>m</em>, T <em>alpha</em>, const T* <em>x</em>, int <em>incx</em>, T* <em>A</em>, int <em>lda</em><big>)</big><a class="headerlink" href="#blas::Syr__c.i.T.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as <tt class="docutils literal"><span class="pre">blas::Her</span></tt>, but <img class="math" src="_images/math/d6c6da8b953fe102fdb4a43af722f2d6c067d322.png" alt="A \in T^{m \times m}"/> is instead
assumed to be <em>symmetric</em>, and the update is <img class="math" src="_images/math/60f2228f5d9b787516af5dd5ffff73a8d6d68566.png" alt="A := \alpha x x^T + A"/>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Syr2__c.i.T.TCP.i.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Syr2</tt><big>(</big>char <em>uplo</em>, int <em>m</em>, T <em>alpha</em>, const T* <em>x</em>, int <em>incx</em>, const T* <em>y</em>, int <em>incy</em>, T* <em>A</em>, int <em>lda</em><big>)</big><a class="headerlink" href="#blas::Syr2__c.i.T.TCP.i.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as <tt class="docutils literal"><span class="pre">blas::Her2</span></tt>, but <img class="math" src="_images/math/d6c6da8b953fe102fdb4a43af722f2d6c067d322.png" alt="A \in T^{m \times m}"/> is instead
assumed to be <em>symmetric</em>, and the update is
<img class="math" src="_images/math/0447e12195681e7f2cdc628c0aa47ea39f468dab.png" alt="A := \alpha ( x y^T + y x^T ) + A"/>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Trmv__c.c.c.i.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Trmv</tt><big>(</big>char <em>uplo</em>, char <em>trans</em>, char <em>diag</em>, int <em>m</em>, const T* <em>A</em>, int <em>lda</em>, T* <em>x</em>, int <em>incx</em><big>)</big><a class="headerlink" href="#blas::Trmv__c.c.c.i.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the update <img class="math" src="_images/math/750a031f3d6311f943a2b3c7c61a864167b15290.png" alt="x := \alpha \mbox{op}(A) x"/>,
where <img class="math" src="_images/math/d6c6da8b953fe102fdb4a43af722f2d6c067d322.png" alt="A \in T^{m \times m}"/> is assumed to be either lower or upper
triangular (depending on whether <tt class="docutils literal"><span class="pre">uplo</span></tt> is &#8216;L&#8217; or &#8216;U&#8217;), unit diagonal if
<tt class="docutils literal"><span class="pre">diag</span></tt> equals &#8216;U&#8217;, and <img class="math" src="_images/math/94ec2b01152e3d51f3471e69f3052c67e93b003d.png" alt="\mbox{op}(A) \in \left\{A,A^T,A^H\right\}"/>
is determined by <tt class="docutils literal"><span class="pre">trans</span></tt> being chosen as &#8216;N&#8217;, &#8216;T&#8217;, or &#8216;C&#8217;, respectively.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Trsv__c.c.c.i.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Trsv</tt><big>(</big>char <em>uplo</em>, char <em>trans</em>, char <em>diag</em>, int <em>m</em>, const T* <em>A</em>, int <em>lda</em>, T* <em>x</em>, int <em>incx</em><big>)</big><a class="headerlink" href="#blas::Trsv__c.c.c.i.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the update <img class="math" src="_images/math/2242914f81176a6f72c1e65afbd553e4739a35dd.png" alt="x := \alpha \mbox{op}(A)^{-1} x"/>,
where <img class="math" src="_images/math/d6c6da8b953fe102fdb4a43af722f2d6c067d322.png" alt="A \in T^{m \times m}"/> is assumed to be either lower or upper
triangular (depending on whether <tt class="docutils literal"><span class="pre">uplo</span></tt> is &#8216;L&#8217; or &#8216;U&#8217;), unit diagonal if
<tt class="docutils literal"><span class="pre">diag</span></tt> equals &#8216;U&#8217;, and <img class="math" src="_images/math/94ec2b01152e3d51f3471e69f3052c67e93b003d.png" alt="\mbox{op}(A) \in \left\{A,A^T,A^H\right\}"/>
is determined by <tt class="docutils literal"><span class="pre">trans</span></tt> being chosen as &#8216;N&#8217;, &#8216;T&#8217;, or &#8216;C&#8217;, respectively.</p>
</dd></dl>

</div>
<div class="section" id="level-3">
<h3>Level 3<a class="headerlink" href="#level-3" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="blas::Gemm__c.c.i.i.i.T.TCP.i.TCP.i.T.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Gemm</tt><big>(</big>char <em>transA</em>, char <em>transB</em>, int <em>m</em>, int <em>n</em>, int <em>k</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, const T* <em>B</em>, int <em>ldb</em>, T <em>beta</em>, T* <em>C</em>, int <em>ldc</em><big>)</big><a class="headerlink" href="#blas::Gemm__c.c.i.i.i.T.TCP.i.TCP.i.T.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the update
<img class="math" src="_images/math/2263aafd9ddbb451a150aed5a7fb321c095377a7.png" alt="C := \alpha \mbox{op}_A(A) \mbox{op}_B(B) + \beta C"/>,
where <img class="math" src="_images/math/f4c5fa72439b6e405ef68fa857ba14b5e122351c.png" alt="\mbox{op}_A"/> and <img class="math" src="_images/math/79fc0b8d73b817966d34d136a47ea15ad9051da3.png" alt="\mbox{op}_B"/> are each determined
(according to <tt class="docutils literal"><span class="pre">transA</span></tt> and <tt class="docutils literal"><span class="pre">transB</span></tt>) in the manner described for
<tt class="docutils literal"><span class="pre">blas::Trmv</span></tt>; it is required that <img class="math" src="_images/math/f1b1c4568ec99e603cd058b88b042a35dbf9040c.png" alt="C \in T^{m \times n}"/> and that
the inner dimension of <img class="math" src="_images/math/4defe469ae42550d5a841a9de32727c2e345f7b3.png" alt="\mbox{op}_A(A) \mbox{op}_B(B)"/> is <tt class="docutils literal"><span class="pre">k</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Hemm__c.c.i.i.T.TCP.i.TCP.i.T.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Hemm</tt><big>(</big>char <em>side</em>, char <em>uplo</em>, int <em>m</em>, int <em>n</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, const T* <em>B</em>, int <em>ldb</em>, T <em>beta</em>, T* <em>C</em>, int <em>ldc</em><big>)</big><a class="headerlink" href="#blas::Hemm__c.c.i.i.T.TCP.i.TCP.i.T.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform either <img class="math" src="_images/math/f980f131f0e109dbe01adada5a8e5f194e70345a.png" alt="C := \alpha A B + \beta C"/> or
<img class="math" src="_images/math/3fa7ed72fd8dc0e08dd0b92d41448b7a3c2b4f78.png" alt="C := \alpha B A + \beta C"/>
(depending upon whether <tt class="docutils literal"><span class="pre">side</span></tt> is respectively &#8216;L&#8217; or &#8216;R&#8217;) where
<img class="math" src="_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/> is assumed to be Hermitian with its data stored in either the
lower or upper triangle (depending upon whether <tt class="docutils literal"><span class="pre">uplo</span></tt> is set to &#8216;L&#8217; or
&#8216;U&#8217;, respectively) and <img class="math" src="_images/math/f1b1c4568ec99e603cd058b88b042a35dbf9040c.png" alt="C \in T^{m \times n}"/>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Her2k__c.c.i.i.T.TCP.i.TCP.i.T.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Her2k</tt><big>(</big>char <em>uplo</em>, char <em>trans</em>, int <em>n</em>, int <em>k</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, const T* <em>B</em>, int <em>ldb</em>, T <em>beta</em>, T* <em>C</em>, int <em>ldc</em><big>)</big><a class="headerlink" href="#blas::Her2k__c.c.i.i.T.TCP.i.TCP.i.T.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform either <img class="math" src="_images/math/d2e0effab4f52d2db4e04738aef5bb2acdbc8bef.png" alt="C := \alpha ( A B^H + B A^H ) \beta C"/> or
<img class="math" src="_images/math/6f726ca404cfeb2c90117bcfbc183576d113159e.png" alt="C := \alpha ( A^H B + B^H A ) \beta C"/> (depending upon whether
<tt class="docutils literal"><span class="pre">trans</span></tt> is respectively &#8216;N&#8217; or &#8216;C&#8217;), where <img class="math" src="_images/math/5af1ad671f831797750c0f96c149433423f7a0b5.png" alt="C \in T^{n \times n}"/>
is assumed to be Hermitian, with the data stored in the triangle specified
by <tt class="docutils literal"><span class="pre">uplo</span></tt> (see <tt class="docutils literal"><span class="pre">blas::Hemv</span></tt>) and the inner dimension of <img class="math" src="_images/math/7dac715b66b41a4c5534f0228d71b78d2ba02458.png" alt="A B^H"/> or
<img class="math" src="_images/math/33fedcdce9d69f98224de0283e7675c813ea3005.png" alt="A^H B"/> is equal to <tt class="docutils literal"><span class="pre">k</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Herk__c.c.i.i.T.TCP.i.T.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Herk</tt><big>(</big>char <em>uplo</em>, char <em>trans</em>, int <em>n</em>, int <em>k</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, T <em>beta</em>, T* <em>C</em>, int <em>ldc</em><big>)</big><a class="headerlink" href="#blas::Herk__c.c.i.i.T.TCP.i.T.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform either <img class="math" src="_images/math/cbde9ec0e5372dc6d0b4936c72ba85dcce83dc02.png" alt="C := \alpha A A^H + \beta C"/> or
<img class="math" src="_images/math/2a781ef3a1335e208bd55c2f437b209e071fa18b.png" alt="C := \alpha A^H A + \beta C"/> (depending upon whether <tt class="docutils literal"><span class="pre">trans</span></tt> is
respectively &#8216;N&#8217; or &#8216;C&#8217;), where <img class="math" src="_images/math/5af1ad671f831797750c0f96c149433423f7a0b5.png" alt="C \in T^{n \times n}"/> is assumed to
be Hermitian with the data stored in the triangle specified by <tt class="docutils literal"><span class="pre">uplo</span></tt>
(see <tt class="docutils literal"><span class="pre">blas::Hemv</span></tt>) and the inner dimension of <img class="math" src="_images/math/5823f08efda4aed563af923dd9e053a0d3bca484.png" alt="A A^H"/> or
<img class="math" src="_images/math/06b093cb92beaa6867227f02ceffa4ee0c2264dd.png" alt="A^H A"/> equal to <tt class="docutils literal"><span class="pre">k</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Hetrmm__c.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Hetrmm</tt><big>(</big>char <em>uplo</em>, int <em>n</em>, T* <em>A</em>, int <em>lda</em><big>)</big><a class="headerlink" href="#blas::Hetrmm__c.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Form either <img class="math" src="_images/math/f990ca0643f98b3c0693cc31def11ce51defbc58.png" alt="A := L^H L"/> or <img class="math" src="_images/math/5b7737c00aed9b202be7c342ba396f44e5315c31.png" alt="A := U U^H"/>, depending upon the
choice of <tt class="docutils literal"><span class="pre">uplo</span></tt>: if <tt class="docutils literal"><span class="pre">uplo</span></tt> equals &#8216;L&#8217;, then <img class="math" src="_images/math/3dbeac972f72548effed8d520fb30f445bb4d26e.png" alt="L \in T^{n \times n}"/>
is equal to the lower triangle of <tt class="docutils literal"><span class="pre">A</span></tt>, otherwise <img class="math" src="_images/math/e2bbebb3bd73f1ae5c64098ab0244f739abf7ca4.png" alt="U"/> is read from
the upper triangle of <tt class="docutils literal"><span class="pre">A</span></tt>. In both cases, the relevant triangle of <tt class="docutils literal"><span class="pre">A</span></tt>
is overwritten in order to store the Hermitian product.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Symm__c.c.i.i.T.TCP.i.TCP.i.T.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Symm</tt><big>(</big>char <em>side</em>, char <em>uplo</em>, int <em>m</em>, int <em>n</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, const T* <em>B</em>, int <em>ldb</em>, T <em>beta</em>, T* <em>C</em>, int <em>ldc</em><big>)</big><a class="headerlink" href="#blas::Symm__c.c.i.i.T.TCP.i.TCP.i.T.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform either <img class="math" src="_images/math/f980f131f0e109dbe01adada5a8e5f194e70345a.png" alt="C := \alpha A B + \beta C"/> or
<img class="math" src="_images/math/3fa7ed72fd8dc0e08dd0b92d41448b7a3c2b4f78.png" alt="C := \alpha B A + \beta C"/>
(depending upon whether <tt class="docutils literal"><span class="pre">side</span></tt> is respectively &#8216;L&#8217; or &#8216;R&#8217;) where
<img class="math" src="_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/> is assumed to be symmetric with its data stored in either the
lower or upper triangle (depending upon whether <tt class="docutils literal"><span class="pre">uplo</span></tt> is set to &#8216;L&#8217; or
&#8216;U&#8217;, respectively) and <img class="math" src="_images/math/f1b1c4568ec99e603cd058b88b042a35dbf9040c.png" alt="C \in T^{m \times n}"/>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Syr2k__c.c.i.i.T.TCP.i.TCP.i.T.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Syr2k</tt><big>(</big>char <em>uplo</em>, char <em>trans</em>, int <em>n</em>, int <em>k</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, const T* <em>B</em>, int <em>ldb</em>, T <em>beta</em>, T* <em>C</em>, int <em>ldc</em><big>)</big><a class="headerlink" href="#blas::Syr2k__c.c.i.i.T.TCP.i.TCP.i.T.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform either <img class="math" src="_images/math/ca8fff8f38f5e7e294589a9a2c6c0dff76880682.png" alt="C := \alpha ( A B^T + B A^T ) \beta C"/> or
<img class="math" src="_images/math/4c95f26c11a927d03c62f8c5b267d2512cb6c40a.png" alt="C := \alpha ( A^T B + B^T A ) \beta C"/> (depending upon whether
<tt class="docutils literal"><span class="pre">trans</span></tt> is respectively &#8216;N&#8217; or &#8216;T&#8217;), where <img class="math" src="_images/math/5af1ad671f831797750c0f96c149433423f7a0b5.png" alt="C \in T^{n \times n}"/>
is assumed to be symmetric, with the data stored in the triangle specified
by <tt class="docutils literal"><span class="pre">uplo</span></tt> (see <tt class="docutils literal"><span class="pre">blas::Symv</span></tt>) and the inner dimension of <img class="math" src="_images/math/a9422811fd62b62fba2916a6558cf99d507ab4d7.png" alt="A B^T"/> or
<img class="math" src="_images/math/5979323a4c458b725e3e6ed044d8223c951a55cb.png" alt="A^T B"/> is equal to <tt class="docutils literal"><span class="pre">k</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Syrk__c.c.i.i.T.TCP.i.T.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Syrk</tt><big>(</big>char <em>uplo</em>, char <em>trans</em>, int <em>n</em>, int <em>k</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, T <em>beta</em>, T* <em>C</em>, int <em>ldc</em><big>)</big><a class="headerlink" href="#blas::Syrk__c.c.i.i.T.TCP.i.T.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform either <img class="math" src="_images/math/41caf8b3a96a5a4730da1640647ada46edf3196b.png" alt="C := \alpha A A^T + \beta C"/> or
<img class="math" src="_images/math/4b972ba19230412c74ea6caecb271ffead249de7.png" alt="C := \alpha A^T A + \beta C"/> (depending upon whether <tt class="docutils literal"><span class="pre">trans</span></tt> is
respectively &#8216;N&#8217; or &#8216;T&#8217;), where <img class="math" src="_images/math/5af1ad671f831797750c0f96c149433423f7a0b5.png" alt="C \in T^{n \times n}"/> is assumed to
be symmetric with the data stored in the triangle specified by <tt class="docutils literal"><span class="pre">uplo</span></tt>
(see <tt class="docutils literal"><span class="pre">blas::Symv</span></tt>) and the inner dimension of <img class="math" src="_images/math/09119e925f3e97200c39bcb6e02e355a48dbcdfc.png" alt="A A^T"/> or
<img class="math" src="_images/math/d462bb806df6b5f9e8fb6875a8cd36327227659f.png" alt="A^T A"/> equal to <tt class="docutils literal"><span class="pre">k</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Trmm__c.c.c.c.i.i.T.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Trmm</tt><big>(</big>char <em>side</em>, char <em>uplo</em>, char <em>trans</em>, char <em>unit</em>, int <em>m</em>, int <em>n</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, T* <em>B</em>, int <em>ldb</em><big>)</big><a class="headerlink" href="#blas::Trmm__c.c.c.c.i.i.T.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs <img class="math" src="_images/math/a49f2dc2af62ed4c7474120fdd9b3f34abb3332b.png" alt="C := \alpha \mbox{op}(A) B"/> or
<img class="math" src="_images/math/3296b833f2ca7b1e8cf84ec2c4bdb67318416e27.png" alt="C := \alpha B \mbox{op}(A)"/>, depending upon whether <tt class="docutils literal"><span class="pre">side</span></tt> was
chosen as &#8216;L&#8217; or &#8216;R&#8217;, respectively. Whether <img class="math" src="_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/> is treated as lower
or upper triangular is determined by whether <tt class="docutils literal"><span class="pre">uplo</span></tt> is &#8216;L&#8217; or &#8216;U&#8217; (setting
<tt class="docutils literal"><span class="pre">unit</span></tt> equal to &#8216;U&#8217; treats <img class="math" src="_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/> as unit diagonal, otherwise it should
be set to &#8216;N&#8217;). <img class="math" src="_images/math/e35702a7785f5cac12907d8175705861a8592e68.png" alt="\mbox{op}"/> is determined in the same manner as in
<tt class="docutils literal"><span class="pre">blas::Trmv</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="blas::Trsm__c.c.c.c.i.i.T.TCP.i.TP.i">
void <tt class="descclassname">blas::</tt><tt class="descname">Trsm</tt><big>(</big>char <em>side</em>, char <em>uplo</em>, char <em>trans</em>, char <em>unit</em>, int <em>m</em>, int <em>n</em>, T <em>alpha</em>, const T* <em>A</em>, int <em>lda</em>, T* <em>B</em>, int <em>ldb</em><big>)</big><a class="headerlink" href="#blas::Trsm__c.c.c.c.i.i.T.TCP.i.TP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs <img class="math" src="_images/math/fcf8d0df825dd022b69ebb076ef134a193d9007c.png" alt="C := \alpha \mbox{op}(A)^{-1} B"/> or
<img class="math" src="_images/math/e93470dea0bf7e41ae7aa4e286eea63740c80437.png" alt="C := \alpha B \mbox{op}(A)^{-1}"/>, depending upon whether <tt class="docutils literal"><span class="pre">side</span></tt> was
chosen as &#8216;L&#8217; or &#8216;R&#8217;, respectively. Whether <img class="math" src="_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/> is treated as lower
or upper triangular is determined by whether <tt class="docutils literal"><span class="pre">uplo</span></tt> is &#8216;L&#8217; or &#8216;U&#8217; (setting
<tt class="docutils literal"><span class="pre">unit</span></tt> equal to &#8216;U&#8217; treats <img class="math" src="_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/> as unit diagonal, otherwise it should
be set to &#8216;N&#8217;). <img class="math" src="_images/math/e35702a7785f5cac12907d8175705861a8592e68.png" alt="\mbox{op}"/> is determined in the same manner as in
<tt class="docutils literal"><span class="pre">blas::Trmv</span></tt>.</p>
</dd></dl>

</div>
</div>
<div class="section" id="lapack">
<h2>LAPACK<a class="headerlink" href="#lapack" title="Permalink to this headline">¶</a></h2>
<p>Only a handful of LAPACK routines are currently used by Elemental: a few
routines for querying floating point characteristics, serial Cholesky and LU
factorization kernels, and a few random utilities.</p>
<div class="section" id="machine-information">
<h3>Machine information<a class="headerlink" href="#machine-information" title="Permalink to this headline">¶</a></h3>
<p>In all of the following functions, <tt class="docutils literal"><span class="pre">R</span></tt> can be equal to either <tt class="docutils literal"><span class="pre">float</span></tt> or
<tt class="docutils literal"><span class="pre">double</span></tt>.</p>
<dl class="function">
<dt id="lapack::MachineEpsilon:R:">
R <tt class="descclassname">lapack::</tt><tt class="descname">MachineEpsilon&lt;R&gt;</tt><big>(</big><big>)</big><a class="headerlink" href="#lapack::MachineEpsilon:R:" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the relative machine precision.</p>
</dd></dl>

<dl class="function">
<dt id="lapack::MachineSafeMin:R:">
R <tt class="descclassname">lapack::</tt><tt class="descname">MachineSafeMin&lt;R&gt;</tt><big>(</big><big>)</big><a class="headerlink" href="#lapack::MachineSafeMin:R:" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum number which can be inverted without underflow.</p>
</dd></dl>

<dl class="function">
<dt id="lapack::MachinePrecision:R:">
R <tt class="descclassname">lapack::</tt><tt class="descname">MachinePrecision&lt;R&gt;</tt><big>(</big><big>)</big><a class="headerlink" href="#lapack::MachinePrecision:R:" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the relative machine precision multiplied by the base.</p>
</dd></dl>

<dl class="function">
<dt id="lapack::MachineUnderflowExponent:R:">
R <tt class="descclassname">lapack::</tt><tt class="descname">MachineUnderflowExponent&lt;R&gt;</tt><big>(</big><big>)</big><a class="headerlink" href="#lapack::MachineUnderflowExponent:R:" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum exponent before (gradual) underflow occurs.</p>
</dd></dl>

<dl class="function">
<dt id="lapack::MachineUnderflowThreshold:R:">
R <tt class="descclassname">lapack::</tt><tt class="descname">MachineUnderflowThreshold&lt;R&gt;</tt><big>(</big><big>)</big><a class="headerlink" href="#lapack::MachineUnderflowThreshold:R:" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underflow threshold: <tt class="docutils literal"><span class="pre">(base)^((underflow</span> <span class="pre">exponent)-1)</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="lapack::MachineOverflowExponent:R:">
R <tt class="descclassname">lapack::</tt><tt class="descname">MachineOverflowExponent&lt;R&gt;</tt><big>(</big><big>)</big><a class="headerlink" href="#lapack::MachineOverflowExponent:R:" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the largest exponent before overflow.</p>
</dd></dl>

<dl class="function">
<dt id="lapack::MachineOverflowThreshold:R:">
R <tt class="descclassname">lapack::</tt><tt class="descname">MachineOverflowThreshold&lt;R&gt;</tt><big>(</big><big>)</big><a class="headerlink" href="#lapack::MachineOverflowThreshold:R:" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overflow threshold:
<tt class="docutils literal"><span class="pre">(1-rel.</span> <span class="pre">prec.))</span> <span class="pre">*</span> <span class="pre">(base)^(overflow</span> <span class="pre">exponent)</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="factorizations">
<h3>Factorizations<a class="headerlink" href="#factorizations" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="lapack::Cholesky__c.i.FCP.i">
void <tt class="descclassname">lapack::</tt><tt class="descname">Cholesky</tt><big>(</big>char <em>uplo</em>, int <em>n</em>, const F* <em>A</em>, int <em>lda</em><big>)</big><a class="headerlink" href="#lapack::Cholesky__c.i.FCP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a Cholesky factorization on <img class="math" src="_images/math/63d9b7b01a6ac29b4f42241b6f1ad0da72ff1813.png" alt="A \in F^{n \times n}"/>, where
<img class="math" src="_images/math/2387492dcc075889d91293d6df8ef260cdbf2b12.png" alt="A(i,j)"/> can be accessed at <tt class="docutils literal"><span class="pre">A[i+j*lda]</span></tt> and <img class="math" src="_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/> is implicitly
Hermitian, with the data stored in the lower triangle if <tt class="docutils literal"><span class="pre">uplo</span></tt> equals
&#8216;L&#8217;, or in the upper triangle if <tt class="docutils literal"><span class="pre">uplo</span></tt> equals &#8216;U&#8217;.</p>
</dd></dl>

<dl class="function">
<dt id="lapack::LU__i.i.FP.i.iP">
void <tt class="descclassname">lapack::</tt><tt class="descname">LU</tt><big>(</big>int <em>m</em>, int <em>n</em>, F* <em>A</em>, int <em>lda</em>, int* <em>p</em><big>)</big><a class="headerlink" href="#lapack::LU__i.i.FP.i.iP" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an LU factorization with partial pivoting on
<img class="math" src="_images/math/14987ac3cddbb7d2d1ea5e4f344f8c2a7553b811.png" alt="A \in F^{m \times n}"/>, where <img class="math" src="_images/math/2387492dcc075889d91293d6df8ef260cdbf2b12.png" alt="A(i,j)"/> can be accessed at
<tt class="docutils literal"><span class="pre">A[i+j*lda]</span></tt>. On exit, the pivots are stored in the vector <tt class="docutils literal"><span class="pre">p</span></tt>, which
should be at least as large as <tt class="docutils literal"><span class="pre">min(m,n)</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="utilities">
<h3>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="lapack::Hegst__i.c.i.FP.i.FCP.i">
void <tt class="descclassname">lapack::</tt><tt class="descname">Hegst</tt><big>(</big>int <em>itype</em>, char <em>uplo</em>, int <em>n</em>, F* <em>A</em>, int <em>lda</em>, const F* <em>B</em>, int <em>ldb</em><big>)</big><a class="headerlink" href="#lapack::Hegst__i.c.i.FP.i.FCP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce a generalized Hermitian-definite eigenvalue problem to Hermitian
standard form. <strong>TODO:</strong> Explain in more detail.</p>
</dd></dl>

<dl class="function">
<dt id="lapack::SafeNorm__R.R">
R <tt class="descclassname">lapack::</tt><tt class="descname">SafeNorm</tt><big>(</big>R <em>alpha</em>, R <em>beta</em><big>)</big><a class="headerlink" href="#lapack::SafeNorm__R.R" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <img class="math" src="_images/math/bec8c1da98d4eb69c134fb00d4cb63c762f15bac.png" alt="\sqrt{\alpha^2+\beta^2}"/> in a manner which avoids
under/overflow. <tt class="docutils literal"><span class="pre">R</span></tt> can be equal to either <tt class="docutils literal"><span class="pre">float</span></tt> or <tt class="docutils literal"><span class="pre">double</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="lapack::SafeNorm__R.R.R">
R <tt class="descclassname">lapack::</tt><tt class="descname">SafeNorm</tt><big>(</big>R <em>alpha</em>, R <em>beta</em>, R <em>gamma</em><big>)</big><a class="headerlink" href="#lapack::SafeNorm__R.R.R" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <img class="math" src="_images/math/9a566e53b62a2fda38d9fff093446069b4310949.png" alt="\sqrt{\alpha^2+\beta^2+\gamma^2}"/> in a manner which avoids
under/overflow. <tt class="docutils literal"><span class="pre">R</span></tt> can be equal to either <tt class="docutils literal"><span class="pre">float</span></tt> or <tt class="docutils literal"><span class="pre">double</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="lapack::TriangularInverse__c.c.i.FCP.i">
void <tt class="descclassname">lapack::</tt><tt class="descname">TriangularInverse</tt><big>(</big>char <em>uplo</em>, char <em>diag</em>, int <em>n</em>, const F* <em>A</em>, int <em>lda</em><big>)</big><a class="headerlink" href="#lapack::TriangularInverse__c.c.i.FCP.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite either the lower or upper triangle of <img class="math" src="_images/math/63d9b7b01a6ac29b4f42241b6f1ad0da72ff1813.png" alt="A \in F^{n \times n}"/>
with its inverse. Which triangle is accessed is determined by <tt class="docutils literal"><span class="pre">uplo</span></tt> (&#8216;L&#8217; for lower or &#8216;U&#8217; for upper), and setting <tt class="docutils literal"><span class="pre">diag</span></tt> equal to &#8216;U&#8217; results in the
triangular matrix being treated as unit diagonal (set <tt class="docutils literal"><span class="pre">diag</span></tt> to &#8216;N&#8217;
otherwise).</p>
</dd></dl>

</div>
</div>
<div class="section" id="mpi">
<h2>MPI<a class="headerlink" href="#mpi" title="Permalink to this headline">¶</a></h2>
<p>All communication within Elemental is built on top of the Message Passing
Interface (MPI). Just like with BLAS and LAPACK, a minimal set of datatype
independent abstractions has been built directly on top of the standard
MPI interface. This has the added benefit of localizing the changes required
for porting Elemental to architectures that do not have full MPI
implementations available.</p>
<div class="section" id="datatypes">
<h3>Datatypes<a class="headerlink" href="#datatypes" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="mpi::Comm">
<em class="property">type </em><tt class="descclassname">mpi::</tt><tt class="descname">Comm</tt><a class="headerlink" href="#mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_Comm</span></tt>.</p>
</dd></dl>

<dl class="type">
<dt id="mpi::Datatype">
<em class="property">type </em><tt class="descclassname">mpi::</tt><tt class="descname">Datatype</tt><a class="headerlink" href="#mpi::Datatype" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_Datatype</span></tt>.</p>
</dd></dl>

<dl class="type">
<dt id="mpi::ErrorHandler">
<em class="property">type </em><tt class="descclassname">mpi::</tt><tt class="descname">ErrorHandler</tt><a class="headerlink" href="#mpi::ErrorHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_Errhandler</span></tt>.</p>
</dd></dl>

<dl class="type">
<dt id="mpi::Group">
<em class="property">type </em><tt class="descclassname">mpi::</tt><tt class="descname">Group</tt><a class="headerlink" href="#mpi::Group" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_Group</span></tt>.</p>
</dd></dl>

<dl class="type">
<dt id="mpi::Op">
<em class="property">type </em><tt class="descclassname">mpi::</tt><tt class="descname">Op</tt><a class="headerlink" href="#mpi::Op" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_Op</span></tt>.</p>
</dd></dl>

<dl class="type">
<dt id="mpi::Request">
<em class="property">type </em><tt class="descclassname">mpi::</tt><tt class="descname">Request</tt><a class="headerlink" href="#mpi::Request" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_Request</span></tt>.</p>
</dd></dl>

<dl class="type">
<dt id="mpi::Status">
<em class="property">type </em><tt class="descclassname">mpi::</tt><tt class="descname">Status</tt><a class="headerlink" href="#mpi::Status" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_Status</span></tt>.</p>
</dd></dl>

<dl class="type">
<dt id="mpi::UserFunction">
<em class="property">type </em><tt class="descclassname">mpi::</tt><tt class="descname">UserFunction</tt><a class="headerlink" href="#mpi::UserFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_User_function</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="constants">
<h3>Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h3>
<dl class="member">
<dt id="mpi::ANY_SOURCE__iC">
const int <tt class="descclassname">mpi::</tt><tt class="descname">ANY_SOURCE</tt><a class="headerlink" href="#mpi::ANY_SOURCE__iC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_ANY_SOURCE</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::ANY_TAG__iC">
const int <tt class="descclassname">mpi::</tt><tt class="descname">ANY_TAG</tt><a class="headerlink" href="#mpi::ANY_TAG__iC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_ANY_TAG</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::THREAD_SINGLE__iC">
const int <tt class="descclassname">mpi::</tt><tt class="descname">THREAD_SINGLE</tt><a class="headerlink" href="#mpi::THREAD_SINGLE__iC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_THREAD_SINGLE</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::THREAD_FUNNELED__iC">
const int <tt class="descclassname">mpi::</tt><tt class="descname">THREAD_FUNNELED</tt><a class="headerlink" href="#mpi::THREAD_FUNNELED__iC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_THREAD_FUNNELED</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::THREAD_SERIALIZED__iC">
const int <tt class="descclassname">mpi::</tt><tt class="descname">THREAD_SERIALIZED</tt><a class="headerlink" href="#mpi::THREAD_SERIALIZED__iC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_THREAD_SERIALIZED</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::THREAD_MULTIPLE__iC">
const int <tt class="descclassname">mpi::</tt><tt class="descname">THREAD_MULTIPLE</tt><a class="headerlink" href="#mpi::THREAD_MULTIPLE__iC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_THREAD_MULTIPLE</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::UNDEFINED__iC">
const int <tt class="descclassname">mpi::</tt><tt class="descname">UNDEFINED</tt><a class="headerlink" href="#mpi::UNDEFINED__iC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_UNDEFINED</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::COMM_WORLD__mpi::CommC">
<a class="reference internal" href="#mpi::Comm" title="mpi::Comm">const mpi::Comm</a> <tt class="descclassname">mpi::</tt><tt class="descname">COMM_WORLD</tt><a class="headerlink" href="#mpi::COMM_WORLD__mpi::CommC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_COMM_WORLD</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::ERRORS_RETURN__mpi::ErrorHandlerC">
<a class="reference internal" href="#mpi::ErrorHandler" title="mpi::ErrorHandler">const mpi::ErrorHandler</a> <tt class="descclassname">mpi::</tt><tt class="descname">ERRORS_RETURN</tt><a class="headerlink" href="#mpi::ERRORS_RETURN__mpi::ErrorHandlerC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_ERRORS_RETURN</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::ERRORS_ARE_FATAL__mpi::ErrorHandlerC">
<a class="reference internal" href="#mpi::ErrorHandler" title="mpi::ErrorHandler">const mpi::ErrorHandler</a> <tt class="descclassname">mpi::</tt><tt class="descname">ERRORS_ARE_FATAL</tt><a class="headerlink" href="#mpi::ERRORS_ARE_FATAL__mpi::ErrorHandlerC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_ERRORS_ARE_FATAL</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::GROUP_EMPTY__mpi::GroupC">
<a class="reference internal" href="#mpi::Group" title="mpi::Group">const mpi::Group</a> <tt class="descclassname">mpi::</tt><tt class="descname">GROUP_EMPTY</tt><a class="headerlink" href="#mpi::GROUP_EMPTY__mpi::GroupC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_GROUP_EMPTY</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::REQUEST_NULL__mpi::RequestC">
<a class="reference internal" href="#mpi::Request" title="mpi::Request">const mpi::Request</a> <tt class="descclassname">mpi::</tt><tt class="descname">REQUEST_NULL</tt><a class="headerlink" href="#mpi::REQUEST_NULL__mpi::RequestC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_REQUEST_NULL</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::MAX__mpi::OpC">
<a class="reference internal" href="#mpi::Op" title="mpi::Op">const mpi::Op</a> <tt class="descclassname">mpi::</tt><tt class="descname">MAX</tt><a class="headerlink" href="#mpi::MAX__mpi::OpC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_MAX</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::PROD__mpi::OpC">
<a class="reference internal" href="#mpi::Op" title="mpi::Op">const mpi::Op</a> <tt class="descclassname">mpi::</tt><tt class="descname">PROD</tt><a class="headerlink" href="#mpi::PROD__mpi::OpC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_PROD</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::SUM__mpi::OpC">
<a class="reference internal" href="#mpi::Op" title="mpi::Op">const mpi::Op</a> <tt class="descclassname">mpi::</tt><tt class="descname">SUM</tt><a class="headerlink" href="#mpi::SUM__mpi::OpC" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">MPI_SUM</span></tt>.</p>
</dd></dl>

<dl class="member">
<dt id="mpi::MIN_COLL_MSG__iC">
const int <tt class="descclassname">mpi::</tt><tt class="descname">MIN_COLL_MSG</tt><a class="headerlink" href="#mpi::MIN_COLL_MSG__iC" title="Permalink to this definition">¶</a></dt>
<dd><p>The minimum message size for collective communication, e.g., the minimum
number of elements contributed by each process in an <tt class="docutils literal"><span class="pre">MPI_Allgather</span></tt>.
By default, it is hardcoded to <tt class="docutils literal"><span class="pre">1</span></tt> in order to avoid problems with
MPI implementations that do not support the <tt class="docutils literal"><span class="pre">0</span></tt> corner case.</p>
</dd></dl>

</div>
<div class="section" id="routines">
<h3>Routines<a class="headerlink" href="#routines" title="Permalink to this headline">¶</a></h3>
<p class="rubric">Environmental</p>
<dl class="function">
<dt id="mpi::Initialize__iR.cPPR">
void <tt class="descclassname">mpi::</tt><tt class="descname">Initialize</tt><big>(</big>int&amp; <em>argc</em>, char**&amp; <em>argv</em><big>)</big><a class="headerlink" href="#mpi::Initialize__iR.cPPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent of <tt class="docutils literal"><span class="pre">MPI_Init</span></tt>
(but notice the difference in the calling convention).</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &quot;elemental.hpp&quot;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">elemental</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">mpi</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span> <span class="p">);</span>
    <span class="p">...</span>
    <span class="n">mpi</span><span class="o">::</span><span class="n">Finalize</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="mpi::InitializeThread__iR.cPPR.i">
int <tt class="descclassname">mpi::</tt><tt class="descname">InitializeThread</tt><big>(</big>int&amp; <em>argc</em>, char**&amp; <em>argv</em>, int <em>required</em><big>)</big><a class="headerlink" href="#mpi::InitializeThread__iR.cPPR.i" title="Permalink to this definition">¶</a></dt>
<dd><p>The threaded equivalent of <tt class="docutils literal"><span class="pre">mpi::Initialize</span></tt>; the return integer indicates
the level of achieved threading support, e.g., <tt class="docutils literal"><span class="pre">mpi::THREAD_MULTIPLE</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::Finalize">
void <tt class="descclassname">mpi::</tt><tt class="descname">Finalize</tt><big>(</big><big>)</big><a class="headerlink" href="#mpi::Finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Shut down the MPI environment, freeing all of the allocated resources.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::Initialized">
bool <tt class="descclassname">mpi::</tt><tt class="descname">Initialized</tt><big>(</big><big>)</big><a class="headerlink" href="#mpi::Initialized" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether or not MPI has been initialized.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::Finalized">
bool <tt class="descclassname">mpi::</tt><tt class="descname">Finalized</tt><big>(</big><big>)</big><a class="headerlink" href="#mpi::Finalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether or not MPI has been finalized.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::Time">
double <tt class="descclassname">mpi::</tt><tt class="descname">Time</tt><big>(</big><big>)</big><a class="headerlink" href="#mpi::Time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current wall-time in seconds.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::OpCreate__mpi::UserFunctionP.b.OpR">
void <tt class="descclassname">mpi::</tt><tt class="descname">OpCreate</tt><big>(</big><a class="reference internal" href="#mpi::UserFunction" title="mpi::UserFunction">mpi::UserFunction*</a> <em>func</em>, bool <em>commutes</em>, Op&amp; <em>op</em><big>)</big><a class="headerlink" href="#mpi::OpCreate__mpi::UserFunctionP.b.OpR" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a custom operation for use in reduction routines, e.g.,
<tt class="docutils literal"><span class="pre">mpi::Reduce</span></tt>, <tt class="docutils literal"><span class="pre">mpi::AllReduce</span></tt>, and <tt class="docutils literal"><span class="pre">mpi::ReduceScatter</span></tt>, where
<tt class="docutils literal"><span class="pre">mpi::UserFunction</span></tt> could be defined as</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">mpi</span> <span class="p">{</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">UserFunction</span><span class="p">)</span> <span class="p">(</span> <span class="kt">void</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">length</span><span class="p">,</span> <span class="n">mpi</span><span class="o">::</span><span class="n">Datatype</span><span class="o">*</span> <span class="n">datatype</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">commutes</span></tt> parameter is also important, as it specifies whether or not
the operation <tt class="docutils literal"><span class="pre">b[i]</span> <span class="pre">=</span> <span class="pre">a[i]</span> <span class="pre">op</span> <span class="pre">b[i],</span> <span class="pre">for</span> <span class="pre">i=0,...,length-1</span></tt>, can be
performed in an arbitrary order (for example, using a minimum spanning tree).</p>
</dd></dl>

<dl class="function">
<dt id="mpi::OpFree__mpi::OpR">
void <tt class="descclassname">mpi::</tt><tt class="descname">OpFree</tt><big>(</big><a class="reference internal" href="#mpi::Op" title="mpi::Op">mpi::Op&amp;</a> <em>op</em><big>)</big><a class="headerlink" href="#mpi::OpFree__mpi::OpR" title="Permalink to this definition">¶</a></dt>
<dd><p>Free the specified MPI reduction operator.</p>
</dd></dl>

<p class="rubric">Communicator manipulation</p>
<dl class="function">
<dt id="mpi::CommRank__mpi::Comm">
int <tt class="descclassname">mpi::</tt><tt class="descname">CommRank</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::CommRank__mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return our rank in the specified communicator.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::CommSize__mpi::Comm">
int <tt class="descclassname">mpi::</tt><tt class="descname">CommSize</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::CommSize__mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of processes in the specified communicator.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::CommCreate__mpi::Comm.mpi::Group.mpi::CommR">
void <tt class="descclassname">mpi::</tt><tt class="descname">CommCreate</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>parentComm</em>, <a class="reference internal" href="#mpi::Group" title="mpi::Group">mpi::Group</a> <em>subsetGroup</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm&amp;</a> <em>subsetComm</em><big>)</big><a class="headerlink" href="#mpi::CommCreate__mpi::Comm.mpi::Group.mpi::CommR" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a communicator (<tt class="docutils literal"><span class="pre">subsetComm</span></tt>) which is a subset of <tt class="docutils literal"><span class="pre">parentComm</span></tt>
consisting of the processes specified by <tt class="docutils literal"><span class="pre">subsetGroup</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::CommDup__mpi::Comm.mpi::CommR">
void <tt class="descclassname">mpi::</tt><tt class="descname">CommDup</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>original</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm&amp;</a> <em>duplicate</em><big>)</big><a class="headerlink" href="#mpi::CommDup__mpi::Comm.mpi::CommR" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of a communicator.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::CommSplit__mpi::Comm.i.i.mpi::CommR">
void <tt class="descclassname">mpi::</tt><tt class="descname">CommSplit</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, int <em>color</em>, int <em>key</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm&amp;</a> <em>newComm</em><big>)</big><a class="headerlink" href="#mpi::CommSplit__mpi::Comm.i.i.mpi::CommR" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the communicator <tt class="docutils literal"><span class="pre">comm</span></tt> into different subcommunicators, where each
process specifies the <tt class="docutils literal"><span class="pre">color</span></tt> (unique integer) of the subcommunicator it
will reside in, as well as its <tt class="docutils literal"><span class="pre">key</span></tt> (rank) for the new subcommunicator.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::CommFree__mpi::CommR">
void <tt class="descclassname">mpi::</tt><tt class="descname">CommFree</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm&amp;</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::CommFree__mpi::CommR" title="Permalink to this definition">¶</a></dt>
<dd><p>Free the specified communicator.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::CongruentComms__mpi::Comm.mpi::Comm">
bool <tt class="descclassname">mpi::</tt><tt class="descname">CongruentComms</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm1</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm2</em><big>)</big><a class="headerlink" href="#mpi::CongruentComms__mpi::Comm.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether or not the two communicators consist of the same set of
processes (in the same order).</p>
</dd></dl>

<dl class="function">
<dt id="mpi::ErrorHandlerSet__mpi::Comm.mpi::ErrorHandler">
void <tt class="descclassname">mpi::</tt><tt class="descname">ErrorHandlerSet</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, <a class="reference internal" href="#mpi::ErrorHandler" title="mpi::ErrorHandler">mpi::ErrorHandler</a> <em>errorHandler</em><big>)</big><a class="headerlink" href="#mpi::ErrorHandlerSet__mpi::Comm.mpi::ErrorHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify the specified communicator to use the specified error-handling
approach.</p>
</dd></dl>

<p class="rubric">Cartesian communicator manipulation</p>
<dl class="function">
<dt id="mpi::CartCreate__mpi::Comm.i.iCP.iCP.b.mpi::CommR">
void <tt class="descclassname">mpi::</tt><tt class="descname">CartCreate</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, int <em>numDims</em>, const int* <em>dimensions</em>, const int* <em>periods</em>, bool <em>reorder</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm&amp;</a> <em>cartComm</em><big>)</big><a class="headerlink" href="#mpi::CartCreate__mpi::Comm.i.iCP.iCP.b.mpi::CommR" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Cartesian communicator (<tt class="docutils literal"><span class="pre">cartComm</span></tt>) from the specified
communicator (<tt class="docutils literal"><span class="pre">comm</span></tt>), given the number of dimensions (<tt class="docutils literal"><span class="pre">numDims</span></tt>),
the sizes of each dimension (<tt class="docutils literal"><span class="pre">dimensions</span></tt>), whether or not each
dimension is periodic (<tt class="docutils literal"><span class="pre">periods</span></tt>), and whether or not the ordering of the
processes may be changed (<tt class="docutils literal"><span class="pre">reorder</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt id="mpi::CartSub__mpi::Comm.iCP.mpi::CommR">
void <tt class="descclassname">mpi::</tt><tt class="descname">CartSub</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, const int* <em>remainingDims</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm&amp;</a> <em>subComm</em><big>)</big><a class="headerlink" href="#mpi::CartSub__mpi::Comm.iCP.mpi::CommR" title="Permalink to this definition">¶</a></dt>
<dd><p>Create this process&#8217;s subcommunicator of <tt class="docutils literal"><span class="pre">comm</span></tt> that results from only
keeping the specified dimensions (<tt class="docutils literal"><span class="pre">0</span></tt> for ignoring and <tt class="docutils literal"><span class="pre">1</span></tt> for keeping).</p>
</dd></dl>

<p class="rubric">Group manipulation</p>
<dl class="function">
<dt id="mpi::GroupRank__mpi::Group">
int <tt class="descclassname">mpi::</tt><tt class="descname">GroupRank</tt><big>(</big><a class="reference internal" href="#mpi::Group" title="mpi::Group">mpi::Group</a> <em>group</em><big>)</big><a class="headerlink" href="#mpi::GroupRank__mpi::Group" title="Permalink to this definition">¶</a></dt>
<dd><p>Return our rank in the specified group.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::GroupSize__mpi::Group">
int <tt class="descclassname">mpi::</tt><tt class="descname">GroupSize</tt><big>(</big><a class="reference internal" href="#mpi::Group" title="mpi::Group">mpi::Group</a> <em>group</em><big>)</big><a class="headerlink" href="#mpi::GroupSize__mpi::Group" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of processes in the specified group.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::CommGroup__mpi::Comm.mpi::GroupR">
void <tt class="descclassname">mpi::</tt><tt class="descname">CommGroup</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, <a class="reference internal" href="#mpi::Group" title="mpi::Group">mpi::Group&amp;</a> <em>group</em><big>)</big><a class="headerlink" href="#mpi::CommGroup__mpi::Comm.mpi::GroupR" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the underlying group from the specified communicator.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::GroupIncl__mpi::Group.i.iCP.mpi::GroupR">
void <tt class="descclassname">mpi::</tt><tt class="descname">GroupIncl</tt><big>(</big><a class="reference internal" href="#mpi::Group" title="mpi::Group">mpi::Group</a> <em>group</em>, int <em>n</em>, const int* <em>ranks</em>, <a class="reference internal" href="#mpi::Group" title="mpi::Group">mpi::Group&amp;</a> <em>subGroup</em><big>)</big><a class="headerlink" href="#mpi::GroupIncl__mpi::Group.i.iCP.mpi::GroupR" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a subgroup of <tt class="docutils literal"><span class="pre">group</span></tt> that consists of the <tt class="docutils literal"><span class="pre">n</span></tt> processes whose
ranks are specified in the <tt class="docutils literal"><span class="pre">ranks</span></tt> array.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::GroupDifference__mpi::Group.mpi::Group.mpi::GroupR">
void <tt class="descclassname">mpi::</tt><tt class="descname">GroupDifference</tt><big>(</big><a class="reference internal" href="#mpi::Group" title="mpi::Group">mpi::Group</a> <em>parent</em>, <a class="reference internal" href="#mpi::Group" title="mpi::Group">mpi::Group</a> <em>subset</em>, <a class="reference internal" href="#mpi::Group" title="mpi::Group">mpi::Group&amp;</a> <em>complement</em><big>)</big><a class="headerlink" href="#mpi::GroupDifference__mpi::Group.mpi::Group.mpi::GroupR" title="Permalink to this definition">¶</a></dt>
<dd><p>Form a group (<tt class="docutils literal"><span class="pre">complement</span></tt>) out of the set of processes which are in
the <tt class="docutils literal"><span class="pre">parent</span></tt> communicator, but not in the <tt class="docutils literal"><span class="pre">subset</span></tt> communicator.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::GroupFree__mpI::GroupR">
void <tt class="descclassname">mpi::</tt><tt class="descname">GroupFree</tt><big>(</big>mpI::Group&amp; <em>group</em><big>)</big><a class="headerlink" href="#mpi::GroupFree__mpI::GroupR" title="Permalink to this definition">¶</a></dt>
<dd><p>Free the specified group.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::GroupTranslateRanks__mpi::Group.i.iCP.mpi::Group.iP">
void <tt class="descclassname">mpi::</tt><tt class="descname">GroupTranslateRanks</tt><big>(</big><a class="reference internal" href="#mpi::Group" title="mpi::Group">mpi::Group</a> <em>origGroup</em>, int <em>size</em>, const int* <em>origRanks</em>, <a class="reference internal" href="#mpi::Group" title="mpi::Group">mpi::Group</a> <em>newGroup</em>, int* <em>newRanks</em><big>)</big><a class="headerlink" href="#mpi::GroupTranslateRanks__mpi::Group.i.iCP.mpi::Group.iP" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ranks within <tt class="docutils literal"><span class="pre">newGroup</span></tt> of the <tt class="docutils literal"><span class="pre">size</span></tt> processes specified
by their ranks in the <tt class="docutils literal"><span class="pre">origGroup</span></tt> communicator using the <tt class="docutils literal"><span class="pre">origRanks</span></tt>
array. The result will be in the <tt class="docutils literal"><span class="pre">newRanks</span></tt> array, which must have been
preallocated to a length at least as large as <tt class="docutils literal"><span class="pre">size</span></tt>.</p>
</dd></dl>

<p class="rubric">Utilities</p>
<dl class="function">
<dt id="mpi::Barrier__mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">Barrier</tt><big>(</big><a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::Barrier__mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Pause until all processes within the <tt class="docutils literal"><span class="pre">comm</span></tt> communicator have called this
routine.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::Wait__mpi::RequestR">
void <tt class="descclassname">mpi::</tt><tt class="descname">Wait</tt><big>(</big><a class="reference internal" href="#mpi::Request" title="mpi::Request">mpi::Request&amp;</a> <em>request</em><big>)</big><a class="headerlink" href="#mpi::Wait__mpi::RequestR" title="Permalink to this definition">¶</a></dt>
<dd><p>Pause until the specified request has completed.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::Test__mpi::RequestR">
bool <tt class="descclassname">mpi::</tt><tt class="descname">Test</tt><big>(</big><a class="reference internal" href="#mpi::Request" title="mpi::Request">mpi::Request&amp;</a> <em>request</em><big>)</big><a class="headerlink" href="#mpi::Test__mpi::RequestR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether or not the specified request has completed.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::IProbe__i.i.mpi::Comm.mpi::StatusR">
bool <tt class="descclassname">mpi::</tt><tt class="descname">IProbe</tt><big>(</big>int <em>source</em>, int <em>tag</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, <a class="reference internal" href="#mpi::Status" title="mpi::Status">mpi::Status&amp;</a> <em>status</em><big>)</big><a class="headerlink" href="#mpi::IProbe__i.i.mpi::Comm.mpi::StatusR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether or not there is a message ready which</p>
<ul class="simple">
<li>is from the process with rank <tt class="docutils literal"><span class="pre">source</span></tt> in the communicator <tt class="docutils literal"><span class="pre">comm</span></tt>
(note that <tt class="docutils literal"><span class="pre">mpi::ANY_SOURCE</span></tt> is allowed)</li>
<li>had the integer tag <tt class="docutils literal"><span class="pre">tag</span></tt></li>
</ul>
<p>If <tt class="docutils literal"><span class="pre">true</span></tt> was returned, then <tt class="docutils literal"><span class="pre">status</span></tt> will have been filled with the
relevant information, e.g., the source&#8217;s rank.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::GetCount:T:__mpi::StatusR">
int <tt class="descclassname">mpi::</tt><tt class="descname">GetCount&lt;T&gt;</tt><big>(</big><a class="reference internal" href="#mpi::Status" title="mpi::Status">mpi::Status&amp;</a> <em>status</em><big>)</big><a class="headerlink" href="#mpi::GetCount:T:__mpi::StatusR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of entries of the specified datatype which are ready to
be received.</p>
</dd></dl>

<p class="rubric">Point-to-point communication</p>
<dl class="function">
<dt id="mpi::Send__TCP.i.i.i.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">Send</tt><big>(</big>const T* <em>buf</em>, int <em>count</em>, int <em>to</em>, int <em>tag</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::Send__TCP.i.i.i.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Send <tt class="docutils literal"><span class="pre">count</span></tt> entries of type <tt class="docutils literal"><span class="pre">T</span></tt> to the process with rank <tt class="docutils literal"><span class="pre">to</span></tt> in the
communicator <tt class="docutils literal"><span class="pre">comm</span></tt>, and tag the message with the integer <tt class="docutils literal"><span class="pre">tag</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::ISend__TCP.i.i.i.mpi::Comm.mpi::RequestR">
void <tt class="descclassname">mpi::</tt><tt class="descname">ISend</tt><big>(</big>const T* <em>buf</em>, int <em>count</em>, int <em>to</em>, int <em>tag</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, <a class="reference internal" href="#mpi::Request" title="mpi::Request">mpi::Request&amp;</a> <em>request</em><big>)</big><a class="headerlink" href="#mpi::ISend__TCP.i.i.i.mpi::Comm.mpi::RequestR" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">mpi::Send</span></tt>, but the call is non-blocking.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::ISSend__TCP.i.i.i.mpi::Comm.mpi::RequestR">
void <tt class="descclassname">mpi::</tt><tt class="descname">ISSend</tt><big>(</big>const T* <em>buf</em>, int <em>count</em>, int <em>to</em>, int <em>tag</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, <a class="reference internal" href="#mpi::Request" title="mpi::Request">mpi::Request&amp;</a> <em>request</em><big>)</big><a class="headerlink" href="#mpi::ISSend__TCP.i.i.i.mpi::Comm.mpi::RequestR" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">mpi::ISend</span></tt>, but the call is in synchronous mode.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::Recv__TP.i.i.i.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">Recv</tt><big>(</big>T* <em>buf</em>, int <em>count</em>, int <em>from</em>, int <em>tag</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::Recv__TP.i.i.i.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive <tt class="docutils literal"><span class="pre">count</span></tt> entries of type <tt class="docutils literal"><span class="pre">T</span></tt> from the process with rank <tt class="docutils literal"><span class="pre">from</span></tt>
in the communicator <tt class="docutils literal"><span class="pre">comm</span></tt>, where the message must have been tagged with
the integer <tt class="docutils literal"><span class="pre">tag</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::IRecv__TP.i.i.i.mpi::Comm.mpi::RequestR">
void <tt class="descclassname">mpi::</tt><tt class="descname">IRecv</tt><big>(</big>T* <em>buf</em>, int <em>count</em>, int <em>from</em>, int <em>tag</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, <a class="reference internal" href="#mpi::Request" title="mpi::Request">mpi::Request&amp;</a> <em>request</em><big>)</big><a class="headerlink" href="#mpi::IRecv__TP.i.i.i.mpi::Comm.mpi::RequestR" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">mpi::Recv</span></tt>, but the call is non-blocking.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::SendRecv__TCP.i.i.i.TP.i.i.i.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">SendRecv</tt><big>(</big>const T* <em>sendBuf</em>, int <em>sendCount</em>, int <em>to</em>, int <em>sendTag</em>, T* <em>recvBuf</em>, int <em>recvCount</em>, int <em>from</em>, int <em>recvTag</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::SendRecv__TCP.i.i.i.TP.i.i.i.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Send <tt class="docutils literal"><span class="pre">sendCount</span></tt> entries of type <tt class="docutils literal"><span class="pre">T</span></tt> to process <tt class="docutils literal"><span class="pre">to</span></tt>, and
simultaneously receive <tt class="docutils literal"><span class="pre">recvCount</span></tt> entries of type <tt class="docutils literal"><span class="pre">T</span></tt> from process
<tt class="docutils literal"><span class="pre">from</span></tt>.</p>
</dd></dl>

<p class="rubric">Collective communication</p>
<dl class="function">
<dt id="mpi::Broadcast__TP.i.i.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">Broadcast</tt><big>(</big>T* <em>buf</em>, int <em>count</em>, int <em>root</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::Broadcast__TP.i.i.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>The contents of <tt class="docutils literal"><span class="pre">buf</span></tt> (<tt class="docutils literal"><span class="pre">count</span></tt> entries of type <tt class="docutils literal"><span class="pre">T</span></tt>) on process <tt class="docutils literal"><span class="pre">root</span></tt>
are duplicated in the local buffers of every process in the communicator.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::Gather__TCP.i.TP.i.i.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">Gather</tt><big>(</big>const T* <em>sendBuf</em>, int <em>sendCount</em>, T* <em>recvBuf</em>, int <em>recvCount</em>, int <em>root</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::Gather__TCP.i.TP.i.i.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Each process sends an independent amount of data (i.e., <tt class="docutils literal"><span class="pre">sendCount</span></tt>
entries of type <tt class="docutils literal"><span class="pre">T</span></tt>) to the process with rank <tt class="docutils literal"><span class="pre">root</span></tt>; the <tt class="docutils literal"><span class="pre">root</span></tt>
process must specify the maximum number of entries sent from each process,
<tt class="docutils literal"><span class="pre">recvCount</span></tt>, so that the data received from process <tt class="docutils literal"><span class="pre">i</span></tt> lies within the
<tt class="docutils literal"><span class="pre">[i*recvCount,(i+1)*recvCount)</span></tt> range of the receive buffer.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::AllGather__TCP.i.TP.i.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">AllGather</tt><big>(</big>const T* <em>sendBuf</em>, int <em>sendCount</em>, T* <em>recvBuf</em>, int <em>recvCount</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::AllGather__TCP.i.TP.i.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">mpi::Gather</span></tt>, but every process receives the result.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::Scatter__TCP.i.TP.i.i.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">Scatter</tt><big>(</big>const T* <em>sendBuf</em>, int <em>sendCount</em>, T* <em>recvBuf</em>, int <em>recvCount</em>, int <em>root</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::Scatter__TCP.i.TP.i.i.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>The same as <tt class="docutils literal"><span class="pre">mpi::Gather</span></tt>, but in reverse: the root process starts with
an array of data and sends the <tt class="docutils literal"><span class="pre">[i*sendCount,(i+1)*sendCount)</span></tt> entries
to process <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::AllToAll__TCP.i.TP.i.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">AllToAll</tt><big>(</big>const T* <em>sendBuf</em>, int <em>sendCount</em>, T* <em>recvBuf</em>, int <em>recvCount</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::AllToAll__TCP.i.TP.i.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>This can be thought of as every process simultaneously scattering data: after
completion, the <tt class="docutils literal"><span class="pre">[i*recvCount,(i+1)*recvCount)</span></tt> portion of the receive
buffer on process <tt class="docutils literal"><span class="pre">j</span></tt> will contain the <tt class="docutils literal"><span class="pre">[j*sendCount,(j+1)*sendCount)</span></tt>
portion of the send buffer on process <tt class="docutils literal"><span class="pre">i</span></tt>, where <tt class="docutils literal"><span class="pre">sendCount</span></tt> refers to
the value specified on process <tt class="docutils literal"><span class="pre">i</span></tt>, and <tt class="docutils literal"><span class="pre">recvCount</span></tt> refers to the value
specified on process <tt class="docutils literal"><span class="pre">j</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::AllToAll__TCP.iCP.iCP.TP.iCP.iCP.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">AllToAll</tt><big>(</big>const T* <em>sendBuf</em>, const int* <em>sendCounts</em>, const int* <em>sendDispls</em>, T* <em>recvBuf</em>, const int* <em>recvCounts</em>, const int* <em>recvDispls</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::AllToAll__TCP.iCP.iCP.TP.iCP.iCP.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as previous <tt class="docutils literal"><span class="pre">mpi::AllToAll</span></tt>, but the amount of data sent to and
received from each process is allowed to vary; after completion, the
<tt class="docutils literal"><span class="pre">[recvDispls[i],recvDispls[i]+recvCounts[i])</span></tt> portion of the receive buffer
on process <tt class="docutils literal"><span class="pre">j</span></tt> will contain the
<tt class="docutils literal"><span class="pre">[sendDispls[j],sendDispls[j]+sendCounts[j])</span></tt> portion of the send buffer
on process <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::Reduce__TCP.TP.i.mpi::Op.i.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">Reduce</tt><big>(</big>const T* <em>sendBuf</em>, T* <em>recvBuf</em>, int <em>count</em>, <a class="reference internal" href="#mpi::Op" title="mpi::Op">mpi::Op</a> <em>op</em>, int <em>root</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::Reduce__TCP.TP.i.mpi::Op.i.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>The <tt class="docutils literal"><span class="pre">root</span></tt> process receives the result of performing</p>
<p><img class="math" src="_images/math/6e83a9b5aaaaeb498df4731faf8441e46bee1f8b.png" alt="S_{p-1} + (S_{n-2} + \cdots (S_2 + (S_1 + S_0)) \cdots )"/>,
where <img class="math" src="_images/math/9e0ec34cd8860ceb97113f81ba768ba739ad5166.png" alt="S_i"/> represents the send buffer of process <tt class="docutils literal"><span class="pre">i</span></tt>, and <img class="math" src="_images/math/77cf26be132ef93923e082ee4153b2cb0ef44a50.png" alt="+"/>
represents the operation specified by <tt class="docutils literal"><span class="pre">op</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::AllReduce__TCP.TP.i.mpi::Op.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">AllReduce</tt><big>(</big>const T* <em>sendBuf</em>, T* <em>recvBuf</em>, int <em>count</em>, <a class="reference internal" href="#mpi::Op" title="mpi::Op">mpi::Op</a> <em>op</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::AllReduce__TCP.TP.i.mpi::Op.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">mpi::Reduce</span></tt>, but every process receives the result.</p>
</dd></dl>

<dl class="function">
<dt id="mpi::ReduceScatter__TCP.TP.iCP.mpi::Op.mpi::Comm">
void <tt class="descclassname">mpi::</tt><tt class="descname">ReduceScatter</tt><big>(</big>const T* <em>sendBuf</em>, T* <em>recvBuf</em>, const int* <em>recvCounts</em>, <a class="reference internal" href="#mpi::Op" title="mpi::Op">mpi::Op</a> <em>op</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#mpi::ReduceScatter__TCP.TP.iCP.mpi::Op.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as <tt class="docutils literal"><span class="pre">mpi::AllReduce</span></tt>, but process <tt class="docutils literal"><span class="pre">0</span></tt> only receives the
<tt class="docutils literal"><span class="pre">[0,recvCounts[0])</span></tt> portion of the result, process <tt class="docutils literal"><span class="pre">1</span></tt> only receives the
<tt class="docutils literal"><span class="pre">[recvCounts[0],recvCounts[0]+recvCounts[1])</span></tt> portion of the result,
etc.</p>
</dd></dl>

</div>
</div>
<div class="section" id="parallel-lcg">
<h2>Parallel LCG<a class="headerlink" href="#parallel-lcg" title="Permalink to this headline">¶</a></h2>
<p>Since it is often necessary to generate a large matrix with pseudo-random
entries in parallel, a method for ensuring that a large set of processes can
each generate independent uniformly random samples is required. The purpose of
Parallel LCG (PLCG) is to provide a provably independent generalization of a
simple (but well-studied) Linear Congruential Generator. Knuth&#8217;s constants from
The Art of Computer Programming Vol. 2 are used.</p>
<div class="section" id="id1">
<h3>Datatypes<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="plcg::UInt32">
<em class="property">type </em><tt class="descclassname">plcg::</tt><tt class="descname">UInt32</tt><a class="headerlink" href="#plcg::UInt32" title="Permalink to this definition">¶</a></dt>
<dd><p>Since the vast majority of modern systems make use of <tt class="docutils literal"><span class="pre">unsigned</span></tt> for
storing 32-bit unsigned integers, we simply hardcode the type. If your
system does not follow this convention, then this typedef will need to be
changed!</p>
</dd></dl>

<dl class="type">
<dt id="plcg::UInt64__struct">
<em class="property">type </em>struct <tt class="descclassname">plcg::</tt><tt class="descname">UInt64</tt><a class="headerlink" href="#plcg::UInt64__struct" title="Permalink to this definition">¶</a></dt>
<dd><p>A custom 64-bit unsigned integer which is simply the concatenation of two
32-bit unsigned integers (<tt class="docutils literal"><span class="pre">UInt32</span></tt>).</p>
</dd></dl>

<dl class="type">
<dt id="plcg::ExpandedUInt64__struct">
<em class="property">type </em>struct <tt class="descclassname">plcg::</tt><tt class="descname">ExpandedUInt64</tt><a class="headerlink" href="#plcg::ExpandedUInt64__struct" title="Permalink to this definition">¶</a></dt>
<dd><p>A custom 64-bit unsigned integer which is stores each of the four 16-bit
pieces within the first 16 bits of a 32-bit unsigned integer. This is done
so that two such expanded 16-bit numbers can be multiplied without any
chance of overflow.</p>
</dd></dl>

</div>
<div class="section" id="lcg-primitives">
<h3>LCG primitives<a class="headerlink" href="#lcg-primitives" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="plcg::Lower16Bits__plcg::UInt32">
<a class="reference internal" href="#plcg::UInt32" title="plcg::UInt32">plcg::UInt32</a> <tt class="descclassname">plcg::</tt><tt class="descname">Lower16Bits</tt><big>(</big><a class="reference internal" href="#plcg::UInt32" title="plcg::UInt32">plcg::UInt32</a> <em>a</em><big>)</big><a class="headerlink" href="#plcg::Lower16Bits__plcg::UInt32" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lower 16 bits of <tt class="docutils literal"><span class="pre">a</span></tt> in the lower 16 bits of the returned
32-bit unsigned integer.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::Upper16Bits__plcg::UInt32">
<a class="reference internal" href="#plcg::UInt32" title="plcg::UInt32">plcg::UInt32</a> <tt class="descclassname">plcg::</tt><tt class="descname">Upper16Bits</tt><big>(</big><a class="reference internal" href="#plcg::UInt32" title="plcg::UInt32">plcg::UInt32</a> <em>a</em><big>)</big><a class="headerlink" href="#plcg::Upper16Bits__plcg::UInt32" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the upper 16 bits of <tt class="docutils literal"><span class="pre">a</span></tt> in the lower 16 bits of the returned
32-bit unsigned integer.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::Expand__plcg::UInt32">
<a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <tt class="descclassname">plcg::</tt><tt class="descname">Expand</tt><big>(</big><a class="reference internal" href="#plcg::UInt32" title="plcg::UInt32">plcg::UInt32</a> <em>a</em><big>)</big><a class="headerlink" href="#plcg::Expand__plcg::UInt32" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand a 32-bit unsigned integer into a 64-bit expanded representation.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::Expand__plcg::UInt64">
<a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <tt class="descclassname">plcg::</tt><tt class="descname">Expand</tt><big>(</big><a class="reference internal" href="#plcg::UInt64__struct" title="plcg::UInt64">plcg::UInt64</a> <em>a</em><big>)</big><a class="headerlink" href="#plcg::Expand__plcg::UInt64" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand a 64-bit unsigned integer into a 64-bit expanded representation.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::Deflate__plcg::ExpandedUInt64">
<a class="reference internal" href="#plcg::UInt64__struct" title="plcg::UInt64">plcg::UInt64</a> <tt class="descclassname">plcg::</tt><tt class="descname">Deflate</tt><big>(</big><a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <em>a</em><big>)</big><a class="headerlink" href="#plcg::Deflate__plcg::ExpandedUInt64" title="Permalink to this definition">¶</a></dt>
<dd><p>Deflate an expanded 64-bit unsigned integer into the standard 64-bit form.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::CarryUpper16Bits__plcg::ExpandedUInt64R">
void <tt class="descclassname">plcg::</tt><tt class="descname">CarryUpper16Bits</tt><big>(</big><a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64&amp;</a> <em>a</em><big>)</big><a class="headerlink" href="#plcg::CarryUpper16Bits__plcg::ExpandedUInt64R" title="Permalink to this definition">¶</a></dt>
<dd><p>Carry the results stored in the upper 16-bits of each of the four pieces
into the next lower 16 bits.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::AddWith64BitMod__plcg::ExpandedUInt64.plcg::ExpandedUInt64">
<a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <tt class="descclassname">plcg::</tt><tt class="descname">AddWith64BitMod</tt><big>(</big><a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <em>a</em>, <a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <em>b</em><big>)</big><a class="headerlink" href="#plcg::AddWith64BitMod__plcg::ExpandedUInt64.plcg::ExpandedUInt64" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <img class="math" src="_images/math/2825a0824bcdf253459598863e27c77047145027.png" alt="a+b \mod 2^{64}"/>.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::MultiplyWith64BitMod__plcg::ExpandedUInt64.plcg::ExpandedUInt64">
<a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <tt class="descclassname">plcg::</tt><tt class="descname">MultiplyWith64BitMod</tt><big>(</big><a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <em>a</em>, <a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <em>b</em><big>)</big><a class="headerlink" href="#plcg::MultiplyWith64BitMod__plcg::ExpandedUInt64.plcg::ExpandedUInt64" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <img class="math" src="_images/math/3701aef25cfbceaf9b1cc3cb9362b9796bae6801.png" alt="ab \mod 2^{64}"/>.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::IntegerPowerWith64BitMod__plcg::ExpandedUInt64.plcg::ExpandedUInt64">
<a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <tt class="descclassname">plcg::</tt><tt class="descname">IntegerPowerWith64BitMod</tt><big>(</big><a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <em>x</em>, <a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <em>n</em><big>)</big><a class="headerlink" href="#plcg::IntegerPowerWith64BitMod__plcg::ExpandedUInt64.plcg::ExpandedUInt64" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <img class="math" src="_images/math/b58f610822e21ee8e4381b6302d5be01d057a6f0.png" alt="x^n \mod 2^{64}"/>.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::Halve__plcg::ExpandedUInt64R">
void <tt class="descclassname">plcg::</tt><tt class="descname">Halve</tt><big>(</big><a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64&amp;</a> <em>a</em><big>)</big><a class="headerlink" href="#plcg::Halve__plcg::ExpandedUInt64R" title="Permalink to this definition">¶</a></dt>
<dd><p><img class="math" src="_images/math/308aefeef1cc5d038e8ce97fe87d2cdfa9fac1d5.png" alt="a := a/2"/>.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::SeedSerialLcg__plcg::UInt64">
void <tt class="descclassname">plcg::</tt><tt class="descname">SeedSerialLcg</tt><big>(</big><a class="reference internal" href="#plcg::UInt64__struct" title="plcg::UInt64">plcg::UInt64</a> <em>globalSeed</em><big>)</big><a class="headerlink" href="#plcg::SeedSerialLcg__plcg::UInt64" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial state of the serial Linear Congruential Generator.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::SeedParallelLcg__plcg::UInt32.plcg::UInt32.plcg::UInt64">
void <tt class="descclassname">plcg::</tt><tt class="descname">SeedParallelLcg</tt><big>(</big><a class="reference internal" href="#plcg::UInt32" title="plcg::UInt32">plcg::UInt32</a> <em>rank</em>, <a class="reference internal" href="#plcg::UInt32" title="plcg::UInt32">plcg::UInt32</a> <em>commSize</em>, <a class="reference internal" href="#plcg::UInt64__struct" title="plcg::UInt64">plcg::UInt64</a> <em>globalSeed</em><big>)</big><a class="headerlink" href="#plcg::SeedParallelLcg__plcg::UInt32.plcg::UInt32.plcg::UInt64" title="Permalink to this definition">¶</a></dt>
<dd><p>Have our process seed a separate LCG meant for parallel computation, where
the calling process has the given rank within a communicator of the
specified size.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::SerialLcg">
<a class="reference internal" href="#plcg::UInt64__struct" title="plcg::UInt64">plcg::UInt64</a> <tt class="descclassname">plcg::</tt><tt class="descname">SerialLcg</tt><big>(</big><big>)</big><a class="headerlink" href="#plcg::SerialLcg" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current state of the serial LCG, and then advance to the next one.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::ParallelLcg">
<a class="reference internal" href="#plcg::UInt64__struct" title="plcg::UInt64">plcg::UInt64</a> <tt class="descclassname">plcg::</tt><tt class="descname">ParallelLcg</tt><big>(</big><big>)</big><a class="headerlink" href="#plcg::ParallelLcg" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current state of our process&#8217;s portion of the parallel LCG,
and then advance to our next local state.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::ManualLcg__plcg::ExpandedUInt64.plcg::ExpandedUInt64.plcg::ExpandedUInt64R">
void <tt class="descclassname">plcg::</tt><tt class="descname">ManualLcg</tt><big>(</big><a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <em>a</em>, <a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64</a> <em>c</em>, <a class="reference internal" href="#plcg::ExpandedUInt64__struct" title="plcg::ExpandedUInt64">plcg::ExpandedUInt64&amp;</a> <em>X</em><big>)</big><a class="headerlink" href="#plcg::ManualLcg__plcg::ExpandedUInt64.plcg::ExpandedUInt64.plcg::ExpandedUInt64R" title="Permalink to this definition">¶</a></dt>
<dd><p><img class="math" src="_images/math/c6d4cda2205e29bfa583acb8b862cad6a579aff2.png" alt="X := a X + c \mod 2^{64}"/>.</p>
</dd></dl>

</div>
<div class="section" id="sampling">
<h3>Sampling<a class="headerlink" href="#sampling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="plcg::SerialUniform">
R <tt class="descclassname">plcg::</tt><tt class="descname">SerialUniform</tt><big>(</big><big>)</big><a class="headerlink" href="#plcg::SerialUniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a uniform sample from <img class="math" src="_images/math/101678300d1aa11009468da8419aaf2c57b795bd.png" alt="(0,1]"/> using the serial LCG.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::ParallelUniform">
R <tt class="descclassname">plcg::</tt><tt class="descname">ParallelUniform</tt><big>(</big><big>)</big><a class="headerlink" href="#plcg::ParallelUniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a uniform sample from <img class="math" src="_images/math/101678300d1aa11009468da8419aaf2c57b795bd.png" alt="(0,1]"/> using the parallel LCG.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::SerialBoxMuller__RR.RR">
void <tt class="descclassname">plcg::</tt><tt class="descname">SerialBoxMuller</tt><big>(</big>R&amp; <em>X</em>, R&amp; <em>Y</em><big>)</big><a class="headerlink" href="#plcg::SerialBoxMuller__RR.RR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return two samples from a normal distribution with mean 0 and standard
deviation of 1 using the serial LCG.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::ParallelBoxMuller__RR.RR">
void <tt class="descclassname">plcg::</tt><tt class="descname">ParallelBoxMuller</tt><big>(</big>R&amp; <em>X</em>, R&amp; <em>Y</em><big>)</big><a class="headerlink" href="#plcg::ParallelBoxMuller__RR.RR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return two samples from a normal distribution with mean 0 and standard
deviation 1, but using the parallel LCG.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::SerialGaussianRandomVariable__RR">
void <tt class="descclassname">plcg::</tt><tt class="descname">SerialGaussianRandomVariable</tt><big>(</big>R&amp; <em>X</em><big>)</big><a class="headerlink" href="#plcg::SerialGaussianRandomVariable__RR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a single sample from a normal distribution with mean 0 and
standard deviation 1 using the serial LCG.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::ParallelGaussianRandomVariable__RR">
void <tt class="descclassname">plcg::</tt><tt class="descname">ParallelGaussianRandomVariable</tt><big>(</big>R&amp; <em>X</em><big>)</big><a class="headerlink" href="#plcg::ParallelGaussianRandomVariable__RR" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a single sample from a normal distribution with mean 0 and
standard deviation 1, but using the parallel LCG.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::SerialGaussianRandomVariable__std::complex:R:R">
void <tt class="descclassname">plcg::</tt><tt class="descname">SerialGaussianRandomVariable</tt><big>(</big>std::complex&lt;R&gt;&amp; <em>X</em><big>)</big><a class="headerlink" href="#plcg::SerialGaussianRandomVariable__std::complex:R:R" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a single complex sample from a normal distribution with mean 0 and
standard deviation 1 using the serial LCG.</p>
</dd></dl>

<dl class="function">
<dt id="plcg::ParallelGaussianRandomVariable__std::complex:R:R">
void <tt class="descclassname">plcg::</tt><tt class="descname">ParallelGaussianRandomVariable</tt><big>(</big>std::complex&lt;R&gt;&amp; <em>X</em><big>)</big><a class="headerlink" href="#plcg::ParallelGaussianRandomVariable__std::complex:R:R" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a single complex sample from a normal distribution with mean 0 and
standard deviation 1, but using the parallel LCG.</p>
</dd></dl>

</div>
</div>
<div class="section" id="pmrrr">
<h2>PMRRR<a class="headerlink" href="#pmrrr" title="Permalink to this headline">¶</a></h2>
<p>Rather than directly using Petschow and Bientinesi&#8217;s parallel implementation of
the Multiple Relatively Robust Representations (MRRR) algorithm, several
simplified interfaces have been exposed.</p>
<div class="section" id="data-structures">
<h3>Data structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="pmrrr::Estimate__struct">
<em class="property">type </em>struct <tt class="descclassname">pmrrr::</tt><tt class="descname">Estimate</tt><a class="headerlink" href="#pmrrr::Estimate__struct" title="Permalink to this definition">¶</a></dt>
<dd><p>For returning upper bounds on the number of local and global eigenvalues
with eigenvalues lying in the specified interval, <img class="math" src="_images/math/cdf3085063293f29962808ba253dec1faa9866fb.png" alt="(a,b]"/>.</p>
<dl class="member">
<dt id="pmrrr::Estimate::numLocalEigenvalues__i">
int <tt class="descname">numLocalEigenvalues</tt><a class="headerlink" href="#pmrrr::Estimate::numLocalEigenvalues__i" title="Permalink to this definition">¶</a></dt>
<dd><p>The upper bound on the number of eigenvalues in the specified interval
that our process stores locally.</p>
</dd></dl>

<dl class="member">
<dt id="pmrrr::Estimate::numGlobalEigenvalues__i">
int <tt class="descname">numGlobalEigenvalues</tt><a class="headerlink" href="#pmrrr::Estimate::numGlobalEigenvalues__i" title="Permalink to this definition">¶</a></dt>
<dd><p>The upper bound on the number of eigenvalues in the specified interval.</p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="pmrrr::Info__struct">
<em class="property">type </em>struct <tt class="descclassname">pmrrr::</tt><tt class="descname">Info</tt><a class="headerlink" href="#pmrrr::Info__struct" title="Permalink to this definition">¶</a></dt>
<dd><p>For returning information about the computed eigenvalues.</p>
<dl class="member">
<dt id="pmrrr::Info::numLocalEigenvalues__i">
int <tt class="descname">numLocalEigenvalues</tt><a class="headerlink" href="#pmrrr::Info::numLocalEigenvalues__i" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of computed eigenvalues that our process locally stores.</p>
</dd></dl>

<dl class="member">
<dt id="pmrrr::Info::numGlobalEigenvalues__i">
int <tt class="descname">numGlobalEigenvalues</tt><a class="headerlink" href="#pmrrr::Info::numGlobalEigenvalues__i" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of computed eigenvalues.</p>
</dd></dl>

<dl class="member">
<dt id="pmrrr::Info::firstLocalEigenvalue__i">
int <tt class="descname">firstLocalEigenvalue</tt><a class="headerlink" href="#pmrrr::Info::firstLocalEigenvalue__i" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the first eigenvalue stored locally on our process.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="compute-all-eigenvalues">
<h3>Compute all eigenvalues<a class="headerlink" href="#compute-all-eigenvalues" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pmrrr::Eig__i.doubleCP.doubleCP.doubleP.mpi::Comm">
<a class="reference internal" href="#pmrrr::Info__struct" title="pmrrr::Info">pmrrr::Info</a> <tt class="descclassname">pmrrr::</tt><tt class="descname">Eig</tt><big>(</big>int <em>n</em>, const double* <em>d</em>, const double* <em>e</em>, double* <em>w</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#pmrrr::Eig__i.doubleCP.doubleCP.doubleP.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all of the eigenvalues of the real symmetric tridiagonal matrix with
diagonal <tt class="docutils literal"><span class="pre">d</span></tt> and subdiagonal <tt class="docutils literal"><span class="pre">e</span></tt>: the eigenvalues will be stored in
<tt class="docutils literal"><span class="pre">w</span></tt> and the work will be divided among the processors in <tt class="docutils literal"><span class="pre">comm</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="pmrrr::Eig__i.doubleCP.doubleCP.doubleP.doubleP.i.mpi::Comm">
<a class="reference internal" href="#pmrrr::Info__struct" title="pmrrr::Info">pmrrr::Info</a> <tt class="descclassname">pmrrr::</tt><tt class="descname">Eig</tt><big>(</big>int <em>n</em>, const double* <em>d</em>, const double* <em>e</em>, double* <em>w</em>, double* <em>Z</em>, int <em>ldz</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em><big>)</big><a class="headerlink" href="#pmrrr::Eig__i.doubleCP.doubleCP.doubleP.doubleP.i.mpi::Comm" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as above, but also compute the corresponding eigenvectors.</p>
</dd></dl>

</div>
<div class="section" id="compute-eigenvalues-within-interval">
<h3>Compute eigenvalues within interval<a class="headerlink" href="#compute-eigenvalues-within-interval" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pmrrr::Eig__i.doubleCP.doubleCP.doubleP.mpi::Comm.double.double">
<a class="reference internal" href="#pmrrr::Info__struct" title="pmrrr::Info">pmrrr::Info</a> <tt class="descclassname">pmrrr::</tt><tt class="descname">Eig</tt><big>(</big>int <em>n</em>, const double* <em>d</em>, const double* <em>e</em>, double* <em>w</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, double <em>a</em>, double <em>b</em><big>)</big><a class="headerlink" href="#pmrrr::Eig__i.doubleCP.doubleCP.doubleP.mpi::Comm.double.double" title="Permalink to this definition">¶</a></dt>
<dd><p>Only compute the eigenvalues lying within the interval <img class="math" src="_images/math/cdf3085063293f29962808ba253dec1faa9866fb.png" alt="(a,b]"/>.</p>
</dd></dl>

<dl class="function">
<dt id="pmrrr::Eig__i.doubleCP.doubleCP.doubleP.doubleP.i.mpi::Comm.double.double">
<a class="reference internal" href="#pmrrr::Info__struct" title="pmrrr::Info">pmrrr::Info</a> <tt class="descclassname">pmrrr::</tt><tt class="descname">Eig</tt><big>(</big>int <em>n</em>, const double* <em>d</em>, const double* <em>e</em>, double* <em>w</em>, double* <em>Z</em>, int <em>ldz</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, double <em>a</em>, double <em>b</em><big>)</big><a class="headerlink" href="#pmrrr::Eig__i.doubleCP.doubleCP.doubleP.doubleP.i.mpi::Comm.double.double" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as above, but also compute the corresponding eigenvectors.</p>
</dd></dl>

<dl class="function">
<dt id="pmrrr::EigEstimate__i.doubleCP.doubleCP.mpi::Comm.double.double">
<a class="reference internal" href="#pmrrr::Estimate__struct" title="pmrrr::Estimate">pmrrr::Estimate</a> <tt class="descclassname">pmrrr::</tt><tt class="descname">EigEstimate</tt><big>(</big>int <em>n</em>, const double* <em>d</em>, const double* <em>w</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, double <em>a</em>, double <em>b</em><big>)</big><a class="headerlink" href="#pmrrr::EigEstimate__i.doubleCP.doubleCP.mpi::Comm.double.double" title="Permalink to this definition">¶</a></dt>
<dd><p>Return upper bounds on the number of local and global eigenvalues lying
within the specified interval.</p>
</dd></dl>

</div>
<div class="section" id="compute-eigenvalues-in-index-range">
<h3>Compute eigenvalues in index range<a class="headerlink" href="#compute-eigenvalues-in-index-range" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pmrrr::Eig__i.doubleCP.doubleCP.doubleP.mpi::Comm.i.i">
<a class="reference internal" href="#pmrrr::Info__struct" title="pmrrr::Info">pmrrr::Info</a> <tt class="descclassname">pmrrr::</tt><tt class="descname">Eig</tt><big>(</big>int <em>n</em>, const double* <em>d</em>, const double* <em>e</em>, double* <em>w</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, int <em>a</em>, int <em>b</em><big>)</big><a class="headerlink" href="#pmrrr::Eig__i.doubleCP.doubleCP.doubleP.mpi::Comm.i.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Only compute the <tt class="docutils literal"><span class="pre">a-b</span></tt> eigenvalues of the tridiagonal matrix, where
<img class="math" src="_images/math/7981a36d5e79f5ce44bc0ca8bccd33fa5167000b.png" alt="0 \le a \le b &lt; n"/>.</p>
</dd></dl>

<dl class="function">
<dt id="pmrrr::Eig__i.doubleCP.doubleCP.doubleP.doubleP.i.mpi::Comm.i.i">
<a class="reference internal" href="#pmrrr::Info__struct" title="pmrrr::Info">pmrrr::Info</a> <tt class="descclassname">pmrrr::</tt><tt class="descname">Eig</tt><big>(</big>int <em>n</em>, const double* <em>d</em>, const double* <em>e</em>, double* <em>w</em>, double* <em>Z</em>, int <em>ldz</em>, <a class="reference internal" href="#mpi::Comm" title="mpi::Comm">mpi::Comm</a> <em>comm</em>, int <em>a</em>, int <em>b</em><big>)</big><a class="headerlink" href="#pmrrr::Eig__i.doubleCP.doubleCP.doubleP.doubleP.i.mpi::Comm.i.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as above, but also compute the corresponding eigenvectors.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/elemental_120x120.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Imported library routines</a><ul>
<li><a class="reference internal" href="#blas">BLAS</a><ul>
<li><a class="reference internal" href="#level-1">Level 1</a></li>
<li><a class="reference internal" href="#level-2">Level 2</a></li>
<li><a class="reference internal" href="#level-3">Level 3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lapack">LAPACK</a><ul>
<li><a class="reference internal" href="#machine-information">Machine information</a></li>
<li><a class="reference internal" href="#factorizations">Factorizations</a></li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mpi">MPI</a><ul>
<li><a class="reference internal" href="#datatypes">Datatypes</a></li>
<li><a class="reference internal" href="#constants">Constants</a></li>
<li><a class="reference internal" href="#routines">Routines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parallel-lcg">Parallel LCG</a><ul>
<li><a class="reference internal" href="#id1">Datatypes</a></li>
<li><a class="reference internal" href="#lcg-primitives">LCG primitives</a></li>
<li><a class="reference internal" href="#sampling">Sampling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pmrrr">PMRRR</a><ul>
<li><a class="reference internal" href="#data-structures">Data structures</a></li>
<li><a class="reference internal" href="#compute-all-eigenvalues">Compute all eigenvalues</a></li>
<li><a class="reference internal" href="#compute-eigenvalues-within-interval">Compute eigenvalues within interval</a></li>
<li><a class="reference internal" href="#compute-eigenvalues-in-index-range">Compute eigenvalues in index range</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="build.html"
                        title="previous chapter">Build system</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="core.html"
                        title="next chapter">Core functionality</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/imports.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="core.html" title="Core functionality"
             >next</a> |</li>
        <li class="right" >
          <a href="build.html" title="Build system"
             >previous</a> |</li>
        <li><a href="index.html">Elemental 0.71 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Jack Poulson.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>